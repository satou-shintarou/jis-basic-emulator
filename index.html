<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JIS-BASICã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ï¼ˆFOR/NEXTãƒ»CSPå¯¾å¿œãƒ»INPUT/IFãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œï¼‰</title>

<style>
  :root{
    --header-h: 68px;            /* ãƒ˜ãƒƒãƒ€ãƒ¼é«˜ã• */
    --vh-pad  : 1.2rem;          /* ä¸Šä¸‹ä½™ç™½ */
    color-scheme: dark;
  }

  /* ===== ãƒ™ãƒ¼ã‚¹ ===== */
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
                 "Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic UI","Meiryo",sans-serif;
    background:#0b0b0c; color:#e7ecef;
  }

  /* ===== ãƒ˜ãƒƒãƒ€ãƒ¼ï¼†ãƒœã‚¿ãƒ³ ===== */
  header{
    position:sticky; top:0; z-index:10;
    display:flex; align-items:center; gap:.6rem; flex-wrap:wrap;
    padding:.7rem 1rem;
    border-bottom:1px solid #262a33;
    background:rgba(11,11,12,.9); backdrop-filter:saturate(150%) blur(6px);
  }
  header h1{ margin:0 1rem 0 0; font-weight:800; font-size:1.05rem; white-space:nowrap; }

  .btn{
    appearance:none; border:0; border-radius:14px;
    font-weight:800; cursor:pointer; padding:.65rem 1rem;
    color:#0a0c0f; letter-spacing:.02em;
    box-shadow: 0 0 0 1px #0a0c0f inset, 0 2px 0 rgba(0,0,0,.18);
    transition: transform .02s ease, filter .08s ease;
  }
  .btn:active{ transform: translateY(1px); }

  .btn-run  { background:#22c55e; }  /* ç·‘ */
  .btn-stop { background:#ef4444; }  /* èµ¤ */
  .btn-clear{ background:#f59e0b; }  /* æ©™ */
  .btn-reset{ background:#3b82f6; }  /* é’ */
  .btn-step { background:#a855f7; }  /* ç´« */
  .btn-cont { background:#14b8a6; }  /* ãƒ†ã‚£ãƒ¼ãƒ« */
  .btn:hover{ filter:brightness(1.05); }

  label.switch{ display:flex; align-items:center; gap:.4rem; font-size:.95rem; margin-left:.4rem; }

  /* ===== 2ã‚«ãƒ©ãƒ ï¼ˆå…¨é«˜å›ºå®šï¼‰ =====
     å·¦ï¼šä¸Šä¸‹2åˆ†å‰²ï¼ˆä¸Š=ã‚¨ãƒ‡ã‚£ã‚¿ 7å‰² / ä¸‹=å®Ÿè¡Œçµæœ 3å‰²ï¼‰
     å³ï¼šä¸Šä¸‹2åˆ†å‰²ï¼ˆä¸Š=å¤‰æ•°ãƒ“ãƒ¥ãƒ¼ 3å‰² / ä¸‹=ãƒˆãƒ¬ãƒ¼ã‚¹ 7å‰²ï¼‰                       */
  .wrap{
    display:grid;
    grid-template-columns: minmax(520px, 1.15fr) minmax(420px, 1fr);
    gap:.75rem;
    padding:.8rem;
    height: calc(100vh - var(--header-h) - var(--vh-pad));
  }
  /* â† ã“ã“ã‚’ 7:3 ã«å¤‰æ›´ */
  .left-col{
    display:grid;
    grid-template-rows: 7fr 3fr;  /* 7å‰²ï¼š3å‰²ï¼ˆã‚¨ãƒ‡ã‚£ã‚¿ï¼šå®Ÿè¡Œç”»é¢ï¼‰ */
    min-height:0; gap:.75rem;
  }
  /* â† ã“ã“ã‚’ 3:7 ã«å¤‰æ›´ï¼ˆå¤‰æ•°ãƒ“ãƒ¥ãƒ¼ï¼šãƒˆãƒ¬ãƒ¼ã‚¹ï¼‰ */
  .right-col{
    display:grid;
    grid-template-rows: 3fr 7fr;  /* 3å‰²ï¼š7å‰²ï¼ˆå¤‰æ•°ãƒ“ãƒ¥ãƒ¼ï¼šãƒˆãƒ¬ãƒ¼ã‚¹ï¼‰ */
    min-height:0; gap:.75rem;
  }

  .card{
    background:#121317; border:1px solid #1f2330; border-radius:18px;
    min-height:0; display:flex; flex-direction:column;
  }
  .card h2{
    position:sticky; top:0; z-index:1;
    margin:0; padding:.65rem 1rem; font-size:.95rem; opacity:.9;
    border-bottom:1px solid #1f2330; background:#121317;
  }
  .card .body{ flex:1; min-height:0; overflow:auto; padding:1rem; }

  textarea#editor{
    width:100%; height:100%; min-height:0;
    background:#0c0d11; color:#e8eefa;
    border:1px solid #2a2f3b; border-radius:12px; padding:.9rem;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size:13px; line-height:1.6;
  }

  .console{
    min-height:0; height:100%;
    background:#000; color:#38f08f;
    border:1px solid #2a2f3b; border-radius:12px;
    padding:.9rem; overflow:auto;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans JP", monospace;
    white-space:pre-wrap;
  }

  /* ===== å¤‰æ•°ãƒ“ãƒ¥ãƒ¼ï¼ãƒˆãƒ¬ãƒ¼ã‚¹ã®è¦–è¦šæ”¯æ´ ===== */
  .changed { background: rgba(234,179,8,.18); transition: background 1.2s ease; }
  .trace-line{ padding:.10rem .25rem; border-left:3px solid #38f08f; margin:.12rem 0; }
  .trace-note{ color:#8ab4f8; margin-left:.4rem; font-size:.85rem; }
  .trace-diff{ color:#eab308; margin-left:.4rem; font-size:.85rem; }

  table.vars { width:100%; border-collapse:collapse; font-size:.92rem; }
  table.vars th, table.vars td{ padding:.22rem .4rem; }
  table.vars thead th{
    border-bottom:1px solid #2a2f3b; font-weight:700; font-size:.9rem;
  }
  table.vars td:nth-child(1){ text-align:left; }
  table.vars td:nth-child(2),
  table.vars td:nth-child(3){ text-align:right; }
  table.vars td:nth-child(4){ text-align:center; }

  .hint{ color:#b8c4d6; opacity:.85; font-size:.85rem; margin-top:.6rem; }

  /* ===== ã‚¹ãƒãƒ›å¹…ä»¥ä¸‹ã¯1ã‚«ãƒ©ãƒ  ===== */
  @media (max-width: 900px){
    .wrap{ grid-template-columns: 1fr; height:auto; }
    .left-col{ grid-template-rows:auto; }
    .right-col{ grid-template-rows:auto; }
  }
</style>
</head>

<body>
<header>
  <h1>JIS-BASICã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ï¼ˆFOR/NEXTãƒ»CSPå¯¾å¿œãƒ»INPUT/IFãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œï¼‰</h1>
  <button class="btn btn-run"   id="btnRun">â–¶ å®Ÿè¡Œ</button>
  <button class="btn btn-stop"  id="btnStop">â–  åœæ­¢</button>
  <button class="btn btn-reset" id="btnReset">â†º ãƒªã‚»ãƒƒãƒˆ</button>
  <button class="btn btn-clear" id="btnClear">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
  <button class="btn btn-step"  id="btnStep">â­ 1è¡Œå®Ÿè¡Œ</button>
  <button class="btn btn-cont"  id="btnCont">â–¶ ç¶šè¡Œ</button>
  <label class="switch"><input type="checkbox" id="chkStep"> ã‚¹ãƒ†ãƒƒãƒ—ON</label>
</header>

<div class="wrap">
  <!-- å·¦ï¼šä¸Šï¼ã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆ7ï¼‰ã€ä¸‹ï¼å®Ÿè¡Œç”»é¢ï¼ˆ3ï¼‰ -->
  <div class="left-col">
    <div class="card">
      <h2>ğŸ“˜ ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿</h2>
      <div class="body">
        <textarea id="editor" spellcheck="false">100 PRINT "ãƒ†ã‚¹ãƒˆé–‹å§‹"
110 LET S = 0
120 FOR I = 1 TO 5
130 LET S = S + I
140 NEXT I
150 IF S >= 15 THEN 180
160 PRINT "ã“ã“ã¯è¡¨ç¤ºã•ã‚Œãªã„ã¯ãš"
170 GOTO 190
180 PRINT "åˆè¨ˆ="; S
190 END</textarea>
        <div class="hint">
          å¯¾å¿œï¼š<code>PRINT</code>ï¼ˆ<code>,</code>ã¯14æ¡ã‚¿ãƒ–ã€<code>;</code>ã¯æ”¹è¡Œãªã—ï¼å¼è©•ä¾¡å¯ï¼‰ã€
          <code>INPUT [PROMPT "â€¦"] : å¤‰æ•°[,å¤‰æ•°â€¦]</code>ã€<code>LET/ä»£å…¥</code>ã€
          <code>IF â€¦ THEN â€¦</code>ï¼ˆå˜æ–‡ï¼‰ï¼<code>IF â€¦ THEN / ELSE / END IF</code>ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã€
          <code>FOR â€¦ TO â€¦ [STEP â€¦]</code>ã€<code>NEXT</code>ã€<code>GOTO</code>ã€<code>END/STOP</code>ã€‚
        </div>
      </div>
    </div>

    <div class="card">
      <h2>ğŸ–¥ï¸ å®Ÿè¡Œç”»é¢</h2>
      <div class="body"><div class="console" id="console"></div></div>
    </div>
  </div>

  <!-- å³ï¼šå¤‰æ•°ãƒ“ãƒ¥ãƒ¼ 3å‰²ï¼ãƒˆãƒ¬ãƒ¼ã‚¹ 7å‰² -->
  <div class="right-col">
    <div class="card">
      <h2>ğŸ” å¤‰æ•°ãƒ“ãƒ¥ãƒ¼</h2>
      <div class="body">
        <table class="vars">
          <thead>
            <tr>
              <th>å¤‰æ•°</th><th>å‰å›</th><th>ç¾åœ¨</th><th>å¤‰åŒ–</th>
            </tr>
          </thead>
          <tbody id="varsBody"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>ğŸ§­ ãƒˆãƒ¬ãƒ¼ã‚¹ï¼ˆè¡Œã”ã¨ã®å› æœï¼‰</h2>
      <div class="body">
        <div id="traceLog" style="font-family:ui-monospace,monospace; font-size:.92rem; line-height:1.45;"></div>
      </div>
    </div>
  </div>
</div>

<!-- ===== INPUTç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« ===== -->
<div class="modal" id="modal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.65); z-index:50;">
  <div class="panel" style="width:min(92vw,520px); background:#161821; border:1px solid #2a2f3b; border-radius:16px; padding:1rem;">
    <div id="modalPrompt" style="margin:.25rem 0 .6rem 0;">? </div>
    <input id="modalInput" placeholder="" style="width:100%; background:#0c0d11; color:#e8eefa; border:1px solid #2a2f3b; border-radius:10px; padding:.6rem .7rem; font-family: ui-monospace, monospace;" />
    <div class="right" style="margin-top:.6rem; display:flex; gap:.5rem; justify-content:flex-end;">
      <button class="btn btn-clear"  id="modalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="btn btn-run"    id="modalOk">OK</button>
    </div>
  </div>
</div>

<script>
/* ===== ï¼ˆä»¥é™ï¼šã‚¨ãƒ³ã‚¸ãƒ³ï¼ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œï¼ãƒˆãƒ¬ãƒ¼ã‚¹å¯è¦–åŒ–ãƒ­ã‚¸ãƒƒã‚¯ï¼‰ ===== */
/* ã“ã“ã‹ã‚‰ã®JSã¯å‰å›ç‰ˆã¨åŒã˜ã§ã™ã€‚ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ã¿å¤‰æ›´ã—ã¦ã„ã¾ã™ã€‚ */

const con       = document.getElementById('console');
const ed        = document.getElementById('editor');
const varsBody  = document.getElementById('varsBody');
const traceLog  = document.getElementById('traceLog');

const btnRun  = document.getElementById('btnRun');
const btnStop = document.getElementById('btnStop');
const btnReset= document.getElementById('btnReset');
const btnClear= document.getElementById('btnClear');
const btnStep = document.getElementById('btnStep');
const btnCont = document.getElementById('btnCont');
const chkStep = document.getElementById('chkStep');

const modal        = document.getElementById('modal');
const modalPrompt  = document.getElementById('modalPrompt');
const modalInput   = document.getElementById('modalInput');
const modalOk      = document.getElementById('modalOk');
const modalCancel  = document.getElementById('modalCancel');

function W(s){ con.textContent += s; con.scrollTop = con.scrollHeight; }
function C(){ con.textContent=''; }
function err(s){ W('âš ï¸ '+s+'\n'); }

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
function normalizeCode(src) {
  src = src.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
  const map = {'ã€€':' ','â€œ':'"','â€':'"','â€':'"','â€Ÿ':'"','â€˜':"'",'â€™':"'",'â€š':"'",'â€¹':'<','â€º':'>','â‰¤':'<=','â‰¥':'>=','Ã—':'*','Ã·':'/','âˆ’':'-','ï¼Œ':',','ï¼›':';','ï¼š':':','\u3000':' '};
  src = src.replace(/[â€œâ€â€â€Ÿâ€˜â€™â€šâ€¹â€ºâ‰¤â‰¥Ã—Ã·âˆ’ï¼Œï¼›ï¼š\u3000]/g, ch => map[ch] || ch);
  src = src.replace(/[\u200B-\u200D\uFEFF]/g, '');
  return src;
}
function normalizeLine(s){ if (!s) return ""; s = s.replace(/^\uFEFF/,""); s = s.replace(/^[\uFEFF\u200B\u200C\u200D\u00A0\u3000]+/,""); s=s.replace(/^\t+/,m=>" ".repeat(m.length)); return s; }

let running=false, pc=0, vars={}, lineIndex={}, program=[];
let loopStack=[];
const initialCode = ed.value;

let stepMode=false, waiting=false;
let lastVars={};

function ask(promptText, preset="", placeholder="") {
  modalPrompt.textContent = promptText || "?";
  modalInput.value = preset; modalInput.placeholder = placeholder || "å€¤ã‚’å…¥åŠ›";
  modal.style.display = "flex"; modalInput.focus();
  return new Promise((resolve, reject) => {
    const cleanup = () => { modal.style.display="none"; modalOk.onclick = modalCancel.onclick = modalInput.onkeydown = null; };
    modalOk.onclick = () => { const v = modalInput.value; cleanup(); resolve(v); };
    modalCancel.onclick = () => { cleanup(); reject(new Error("cancel")); };
    modalInput.onkeydown = (e) => { if (e.key==="Enter") modalOk.click(); if (e.key==="Escape") modalCancel.click(); };
  });
}

/* --- ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚ºï¼å¼è©•ä¾¡ --- */
function tokenize(s){
  const out=[]; let i=0;
  const isAlpha=c=>/[A-Za-z_]/.test(c), isAlnum=c=>/[A-Za-z0-9_]/.test(c);
  while(i<s.length){
    const ch=s[i];
    if(/\s/.test(ch)){ i++; continue; }
    if(ch=='"'){ let j=i+1, buf=''; while(j<s.length&&s[j]!=='"'){ buf+=s[j++]; } j++; out.push({t:'str',v:buf}); i=j; continue; }
    if(/[0-9.]/.test(ch)){ let j=i, num='', dot=false; while(j<s.length&&/[0-9.]/.test(s[j])){ if(s[j]==='.'&&dot) break; if(s[j]==='.') dot=true; num+=s[j++]; } out.push({t:'num',v:Number(num)}); i=j; continue; }
    if(isAlpha(ch)){ let j=i, id=''; while(j<s.length&&isAlnum(s[j])) id+=s[j++]; const up=id.toUpperCase(); if(up==='AND'||up==='OR'){ out.push({t:'op',v:up}); } else { out.push({t:'id',v:up}); } i=j; continue; }
    const two=s.slice(i,i+2);
    if(['>=','<=','<>'].includes(two)){ out.push({t:'op',v:two}); i+=2; continue; }
    if('+-*/^=()<>'.includes(ch)){ if(ch==='('||ch===')') out.push({t:'par',v:ch}); else out.push({t:'op',v:ch}); i++; continue; }
    if(ch===','){ out.push({t:'comma'}); i++; continue; }
    throw new Error('æœªçŸ¥ã®æ–‡å­—: '+ch+' (U+'+ch.charCodeAt(0).toString(16).toUpperCase().padStart(4,'0')+')');
  }
  out.push({t:'eof'}); return out;
}
function evalExpr(expr){
  const tokens=tokenize(expr); let i=0;
  const peek=()=>tokens[i]||{t:'eof'};
  const consume=()=>tokens[i++]||{t:'eof'};
  const toNum=v=> typeof v==='boolean'? (v?1:0) : (typeof v==='number'? v : Number(v));

  const parseExpr=()=>parseOr();
  function parseOr(){ let L=parseAnd(); while(peek().t==='op'&&peek().v==='OR'){ consume(); const R=parseAnd(); L=(toNum(L)||toNum(R))?1:0; } return L; }
  function parseAnd(){ let L=parseCmp(); while(peek().t==='op'&&peek().v==='AND'){ consume(); const R=parseCmp(); L=(toNum(L)&&toNum(R))?1:0; } return L; }
  function parseCmp(){ let L=parseAdd(); const p=peek(); if(p.t==='op'&&['=','<>','<','<=','>','>='].includes(p.v)){ consume(); const R=parseAdd(); switch(p.v){case '=':return (L==R)?1:0;case '<>':return (L!=R)?1:0;case '<':return (toNum(L)<toNum(R))?1:0;case '<=':return (toNum(L)<=toNum(R))?1:0;case '>':return (toNum(L)>toNum(R))?1:0;case '>=':return (toNum(L)>=toNum(R))?1:0;} } return L; }
  function parseAdd(){ let L=parseMul(); while(peek().t==='op'&&(peek().v==='+'||peek().v==='-')){ const op=consume().v; const R=parseMul(); L=(op==='+')? toNum(L)+toNum(R) : toNum(L)-toNum(R); } return L; }
  function parseMul(){ let L=parsePow(); while(peek().t==='op'&&(peek().v==='*'||peek().v==='/')){ const op=consume().v; const R=parsePow(); L=(op==='*')? toNum(L)*toNum(R) : toNum(L)/toNum(R); } return L; }
  function parsePow(){ let L=parseUnary(); while(peek().t==='op'&&peek().v==='^'){ consume(); const R=parseUnary(); L=Math.pow(toNum(L), toNum(R)); } return L; }
  function parseUnary(){ const p=peek(); if(p.t==='op'&&(p.v==='+'||p.v==='-')){ consume(); const v=parseUnary(); return p.v==='-'? -toNum(v) : toNum(v); } return parsePrimary(); }
  function parsePrimary(){
    const t=peek();
    if(t.t==='num'){ consume(); return t.v; }
    if(t.t==='str'){ consume(); return t.v; }
    if(t.t==='id'){ const name=t.v; consume(); return getVar(name); }
    if(t.t==='par'&&t.v==='('){ consume(); const v=parseExpr(); if(peek().t!=='par'||peek().v!==')') throw new Error(')ãŒå¿…è¦'); consume(); return v; }
    throw new Error('å¼ã‚¨ãƒ©ãƒ¼');
  }
  return parseExpr();
}

/* --- å¤‰æ•° --- */
function toKey(s){ return s.toUpperCase(); }
function getVar(n){ return (n=toKey(n), vars[n]??0); }
function setVar(n,v){ vars[toKey(n)]=v; }

/* --- ãƒ—ãƒ­ã‚°ãƒ©ãƒ è§£æ --- */
function parseProgram(src){
  src = src.replace(/^\uFEFF/, "");
  const raw=src.split(/\r?\n/); program=[]; lineIndex={};
  for(const r of raw){
    const line = normalizeLine(r);
    if(!line.trim()) continue;
    const m=line.match(/^(\d+)\s+(.*)$/);
    if(!m) throw new Error('è¡Œç•ªå·ãŒå¿…è¦: '+line);
    program.push({ln:parseInt(m[1],10), text:m[2].trim()});
  }
  program.sort((a,b)=>a.ln-b.ln);
  program.forEach((st,i)=> lineIndex[st.ln]=i);
}

/* --- 1è¡Œå®Ÿè¡Œ --- */
async function execLine(idx){
  const {ln,text}=program[idx];
  const up=text.toUpperCase();

  if(/^REM/.test(up)) return;
  if(/^(END|STOP)$/.test(up)) {running=false; return;}

  if(/^PRINT\b/i.test(up)){
    const body = text.replace(/^PRINT\s*/i,'');
    const parts = []; let buf='', inStr=false, depth=0;
    for(let i=0;i<body.length;i++){
      const c=body[i];
      if(c==='"'){ inStr=!inStr; buf+=c; continue; }
      if(!inStr){
        if(c==='('){ depth++; buf+=c; continue; }
        if(c===')'){ depth--; buf+=c; continue; }
        if((c===','||c===';')&&depth===0){ parts.push({expr:buf.trim(),sep:c}); buf=''; continue; }
      }
      buf+=c;
    }
    parts.push({expr:buf.trim(),sep:null});
    let lineOut='', col=0, lastSep=null;
    for(const p of parts){
      if(p.expr.length>0){
        const v=evalExpr(p.expr); const s=(typeof v==='string')?v:String(v);
        lineOut+=s; col+=s.length;
      }
      lastSep = p.sep;
      if(p.sep===','){ const zone=14; const rem=col%zone; const pad=(rem===0)?zone:(zone-rem); lineOut+=' '.repeat(pad); col+=pad; }
    }
    W(lineOut + (lastSep===';'?'':'\n')); return;
  }

  let mIfBlk=text.match(/^IF\s+(.+?)\s+THEN\s*$/i);
  if(mIfBlk){
    const cond=!!evalExpr(mIfBlk[1]); let depth=0, elseIdx=-1, endIdx=-1;
    for(let j=idx+1;j<program.length;j++){
      const uj=program[j].text.toUpperCase().trim();
      if(/^IF\s+.+\s+THEN\s*$/.test(uj)){ depth++; continue; }
      if(/^END\s+IF$/.test(uj)){ if(depth===0){ endIdx=j; break; } else { depth--; continue; } }
      if(/^ELSE$/.test(uj)){ if(depth===0 && elseIdx===-1) elseIdx=j; }
    }
    if(endIdx<0) throw new Error('IF ã«å¯¾å¿œã™ã‚‹ END IF ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    if(!cond) pc=(elseIdx>=0?elseIdx:endIdx)-1;
    return;
  }
  if(/^ELSE$/i.test(up.trim())){
    let depth=0, endIdx=-1;
    for(let j=idx+1;j<program.length;j++){
      const uj=program[j].text.toUpperCase().trim();
      if(/^IF\s+.+\s+THEN\s*$/.test(uj)){ depth++; continue; }
      if(/^END\s+IF$/.test(uj)){ if(depth===0){ endIdx=j; break; } else { depth--; continue; } }
    }
    if(endIdx<0) throw new Error('ELSE ã«å¯¾å¿œã™ã‚‹ END IF ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    pc = endIdx-1; return;
  }
  if(/^END\s+IF$/i.test(up.trim())){ return; }

  if(/^INPUT\b/i.test(up)){
    let promptTxt="?", varPart=null, m;
    m=text.match(/^INPUT\s+PROMPT\s+"([^"]*)"\s*:\s*(.+)$/i);
    if(m){ promptTxt=m[1]; varPart=m[2]; }
    else{ m=text.match(/^INPUT\s+(.+)$/i); if(m){ varPart=m[1]; } }
    if(!varPart) throw new Error("INPUT æ§‹æ–‡ã‚¨ãƒ©ãƒ¼");
    const names=varPart.split(/\s*,\s*/); const placeholder=(names.length===1)?"ä¾‹: 1":"ä¾‹: "+names.map((_,i)=>i+1).join(", ");
    while(true){
      const ans=await ask(promptTxt,"",placeholder);
      const values=ans.split(/\s*,\s*/);
      if(values.length<names.length){ err("å…¥åŠ›ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"); continue; }
      let ok=true; const parsed=[];
      for(let i=0;i<names.length;i++){
        const raw=(values[i]??"").trim(); if(raw===""){ ok=false; break; }
        const num=Number(raw); if(Number.isNaN(num)){ ok=false; break; }
        parsed.push(num);
      }
      if(!ok){ err("æ•°å€¤ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ã®å½¢å¼ã«å¾“ã£ã¦å†å…¥åŠ›ã‚’ã€‚"); continue; }
      for(let i=0;i<names.length;i++) setVar(names[i].toUpperCase(), parsed[i]);
      break;
    }
    return;
  }

  if(/^LET\b/i.test(up) || /^[A-Z]/.test(text)){
    const m=text.replace(/^LET\s+/i,'').match(/^([A-Z][A-Z0-9_]*)\s*=\s*(.+)$/i);
    if(m){ setVar(m[1], evalExpr(m[2])); return; }
  }

  let mf=text.match(/^FOR\s+([A-Z][A-Z0-9_]*)\s*=\s*(.+?)\s+TO\s+(.+?)(?:\s+STEP\s+(.+))?\s*$/i);
  if(mf){
    const v=mf[1], init=Number(evalExpr(mf[2])), fin=Number(evalExpr(mf[3]));
    const step=(mf[4]!=null)?Number(evalExpr(mf[4])):1;
    if(!isFinite(init)||!isFinite(fin)||!isFinite(step)) throw new Error('FORã®å€¤ãŒæ•°å€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
    if(step===0) throw new Error('STEP ã¯ 0 ã«ã§ãã¾ã›ã‚“');
    setVar(v, init);
    let depth=0, nextIndex=-1;
    for(let j=idx+1;j<program.length;j++){
      const u=program[j].text.toUpperCase();
      if(/^FOR\b/.test(u)) depth++;
      if(/^NEXT\b/.test(u)){ if(depth===0){ nextIndex=j; break; } else depth--; }
    }
    if(nextIndex<0) throw new Error('FOR ã«å¯¾å¿œã™ã‚‹ NEXT ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    const exec=(step>0)?(init<=fin):(init>=fin);
    if(!exec){ pc=nextIndex; return; }
    loopStack.push({var:v, fin, step, start:idx+1, forIndex:idx, nextIndex});
    return;
  }

  let mn=text.match(/^NEXT\s*([A-Z][A-Z0-9_]*)?\s*$/i);
  if(mn){
    if(loopStack.length===0) throw new Error('NEXT ã«å¯¾å¿œã™ã‚‹ FOR ãŒã‚ã‚Šã¾ã›ã‚“');
    const ctx=loopStack[loopStack.length-1];
    if(mn[1]&&mn[1].toUpperCase()!==ctx.var) throw new Error('NEXT '+mn[1]+' ã¯ FOR '+ctx.var+' ã¨ä¸€è‡´ã—ã¾ã›ã‚“');
    const nv=Number(getVar(ctx.var))+ctx.step; setVar(ctx.var,nv);
    const cont=(ctx.step>0)?(nv<=ctx.fin):(nv>=ctx.fin);
    if(cont) pc=ctx.start-1; else loopStack.pop();
    return;
  }

  let mg=text.match(/^GOTO\s+(\d+)\s*$/i);
  if(mg){ const t=+mg[1]; if(lineIndex[t]==null) throw new Error('è¡Œ '+t+' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); pc=lineIndex[t]-1; return; }

  let mIf=text.match(/^IF\s+(.+?)\s+THEN\s+(.+)$/i);
  if(mIf){
    const cond=!!evalExpr(mIf[1]);
    if(cond){
      const stmt=mIf[2].trim();
      if(/^\d+$/.test(stmt)){
        const t=+stmt; if(lineIndex[t]==null) throw new Error('è¡Œ '+t+' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); pc=lineIndex[t]-1;
      }else{
        const tmp={ln, text:stmt}; program.splice(idx+1,0,tmp);
        for(const k in lineIndex){ if(lineIndex[k]>idx) lineIndex[k]++; }
      }
    }
    return;
  }

  throw new Error('æœªçŸ¥ã®æ–‡: '+text);
}

/* --- ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œï¼å¯è¦–åŒ– --- */
function snapshot(obj){ const out={}; for(const k of Object.keys(obj||{})) out[k]=obj[k]; return out; }
function diffVars(before, after){
  const keys=new Set([...Object.keys(before), ...Object.keys(after)]);
  const out=[];
  for(const k of keys){
    const b=before[k], a=after[k];
    if(b!==a){
      out.push({name:k, old:b, now:a, dir:(typeof b==='number'&&typeof a==='number')?(a>b?'â†‘':(a<b?'â†“':'=')):'â†”'});
    }
  }
  return out.sort((x,y)=>x.name.localeCompare(y.name));
}
function updateVarsUI(curVars, changes){
  const keys=new Set([...Object.keys(lastVars), ...Object.keys(curVars)]);
  const rows=[];
  keys.forEach(k=>{
    const b=lastVars[k], a=curVars[k], changed=(b!==a);
    rows.push(`<tr class="${changed?'changed':''}">
      <td>${k}</td>
      <td>${b===undefined?'':(typeof b==='string'?'"'+b+'"':b)}</td>
      <td>${a===undefined?'':(typeof a==='string'?'"'+a+'"':a)}</td>
      <td>${changed?((typeof b==='number'&&typeof a==='number')?(a>b?'â†‘':(a<b?'â†“':'=')):'â†”'):''}</td>
    </tr>`);
  });
  varsBody.innerHTML=rows.join(''); lastVars=snapshot(curVars);
  setTimeout(()=>{ for(const tr of varsBody.querySelectorAll('.changed')) tr.classList.remove('changed'); }, 900);
}
function logTrace({ln, text, diff, note}){
  const lnStr=(ln==null)?'(END)':(`è¡Œ ${ln}`); const code=(text!=null)?escapeHtml(text):'';
  const diffs=(diff&&diff.length>0)?' / å¤‰æ›´: '+diff.map(d=>`${d.name}:${d.old===undefined?'':d.old}â†’${d.now}`).join(', '):'';
  const noteStr=note?`<span class="trace-note">${escapeHtml(note)}</span>`:''; const diffStr=diffs?`<span class="trace-diff">${escapeHtml(diffs)}</span>`:'';
  const line=document.createElement('div'); line.className='trace-line';
  line.innerHTML=`<b>${lnStr}</b>  ${code} ${noteStr}${diffStr}`;
  traceLog.appendChild(line); traceLog.scrollTop=traceLog.scrollHeight;
}
function focusLine(ln){
  if(!ln) return;
  const lines=ed.value.split(/\r?\n/); let pos=0;
  for(const line of lines){
    const m=line.match(/^(\d+)\s+/);
    if(m && Number(m[1])===ln){
      const start=pos, end=pos+line.length; ed.focus(); if(ed.setSelectionRange) ed.setSelectionRange(start,end);
      const upto=ed.value.slice(0,start); const lineHeight=18; ed.scrollTop=Math.max(0,(upto.split(/\r?\n/).length-3)*lineHeight); return;
    }
    pos+=line.length+1;
  }
}
async function resetIfNeeded(){
  if(!program||program.length===0){ parseProgram(normalizeCode(ed.value)); lastVars=snapshot(vars); }
  if(!running) running=true; waiting=false;
}
async function stepOnce(){
  await resetIfNeeded();
  if(pc>=program.length){ logTrace({ln:null, text:'<END>', note:'ãƒ—ãƒ­ã‚°ãƒ©ãƒ çµ‚äº†'}); return; }
  const before=snapshot(vars); const prevPc=pc;
  try{ await execLine(pc);}catch(e){}
  pc++;
  const after=snapshot(vars); const diff=diffVars(before,after);
  const curLn=program[prevPc].ln, curTx=program[prevPc].text;
  focusLine(curLn); updateVarsUI(after,diff); logTrace({ln:curLn,text:curTx,diff}); waiting=true;
}
async function runToNextPause(){
  while(stepMode && waiting===false && pc<program.length){
    const before=snapshot(vars); const prevPc=pc;
    try{ await execLine(pc);}catch(e){}
    pc++;
    const after=snapshot(vars); const diff=diffVars(before,after);
    const curLn=program[prevPc].ln, curTx=program[prevPc].text;
    focusLine(curLn); updateVarsUI(after,diff); logTrace({ln:curLn,text:curTx,diff});
    if(stepMode){ waiting=true; break; }
  }
}

/* --- run/stop/reset/clear --- */
async function run(){
  if(stepMode){ await stepOnce(); return; }
  C(); vars={}; loopStack=[]; pc=0; running=true; traceLog.textContent=''; W('ğŸš€ ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œé–‹å§‹\n');
  try{ parseProgram(normalizeCode(ed.value)); }catch(e){ err('æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: '+e.message); return; }
  while(running&&pc<program.length){
    const before=snapshot(vars); const prevPc=pc;
    try{ await execLine(pc);}catch(e){ err('å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ï¼ˆè¡Œ '+program[pc].ln+'ï¼‰: '+e.message); running=false; }
    pc++;
    const after=snapshot(vars); const diff=diffVars(before,after);
    const curLn=program[prevPc].ln, curTx=program[prevPc].text;
    updateVarsUI(after,diff); logTrace({ln:curLn,text:curTx,diff});
    if(pc>100000){ err('å®Ÿè¡ŒãŒé•·ã™ãã¾ã™ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—ï¼Ÿï¼‰'); running=false; }
  }
}
function stop(){ running=false; }
function reset(){ stop(); ed.value=initialCode; C(); traceLog.textContent=''; varsBody.innerHTML=''; W('ğŸ”„ ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ\n'); program=[]; vars={}; loopStack=[]; pc=0; }
function clear(){ stop(); ed.value=''; C(); traceLog.textContent=''; varsBody.innerHTML=''; W('ğŸ§¹ ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼ˆæ–°ã—ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼‰\n'); program=[]; vars={}; loopStack=[]; pc=0; }

/* --- ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ --- */
btnRun.onclick  = ()=>{ if(!running || stepMode) run(); };
btnStop.onclick = ()=> stop();
btnReset.onclick= ()=> reset();
btnClear.onclick= ()=> clear();
chkStep.addEventListener('change', ()=> stepMode = chkStep.checked);
btnStep.addEventListener('click', async ()=>{ stepMode=true; chkStep.checked=true; waiting=false; await stepOnce(); });
btnCont.addEventListener('click', async ()=>{ stepMode=true; chkStep.checked=true; waiting=false; await runToNextPause(); });
</script>
</body>
</html>
