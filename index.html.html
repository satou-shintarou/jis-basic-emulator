<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JIS-BASICã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ï¼ˆFOR/NEXTãƒ»CSPå¯¾å¿œãƒ»INPUT/IFãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œï¼‰</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", "Meiryo", sans-serif; background:#0b0b0c; color:#e7ecef; }
  header { position: sticky; top:0; z-index:10; display:flex; gap:.5rem; align-items:center; padding:.75rem 1rem; border-bottom:1px solid #262a33; background:rgba(11,11,12,.9); backdrop-filter:saturate(150%) blur(6px); }
  h1 { font-size:1.05rem; margin:0 .5rem 0 0; font-weight:800; }
  button { border:0; border-radius:14px; padding:.6rem .9rem; font-weight:700; cursor:pointer; }
  .run { background:#10b981; color:#05130f; }
  .stop { background:#ef4444; color:#2b0707; }
  .reset { background:#0ea5e9; color:#07121a; }
  .clear { background:#6b7280; color:#0a0c0f; }
  .wrap { max-width:1200px; margin: 0 auto; padding: 1rem; display:grid; grid-template-columns: 1fr 1fr; gap:1rem; }
  .card { background:#121317; border:1px solid #1f2330; border-radius:18px; }
  .card h2 { margin:0; padding:.75rem 1rem; font-size:.9rem; opacity:.85; border-bottom:1px solid #1f2330;}
  textarea { width:100%; min-height:520px; background:#0c0d11; color:#e8eefa; border:1px solid #2a2f3b; border-radius:12px; padding:.9rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:13px; line-height:1.6; }
  .console { min-height:520px; background:#000; color:#38f08f; border:1px solid #2a2f3b; border-radius:12px; padding:.9rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:13px; overflow:auto; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans JP", monospace; }

  /* å¤‰æ•°ãŒå¤‰åŒ–ã—ãŸè¡Œã‚’é»„è‰²ã£ã½ãå…‰ã‚‰ã›ã‚‹ */
  .changed {
    background: rgba(234,179,8,.18);
    transition: background 1.2s ease;
  }
  .trace-line {
    padding:.10rem .25rem; border-left:3px solid #38f08f; margin:.1rem 0;
  }
  .trace-note {
    color:#8ab4f8; margin-left:.4rem; font-size:.85rem;
  }
  .trace-diff {
    color:#eab308; margin-left:.4rem; font-size:.85rem;
  }

  .hint { padding:.5rem 1rem 1rem 1rem; font-size:.8rem; color:#b8c4d6; opacity:.8; }
  @media (max-width: 900px) {
    .wrap { grid-template-columns: 1fr; }
    textarea, .console { min-height: 360px; }
  }
  .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.65); z-index:50; }
  .modal .panel { width:min(92vw, 520px); background:#161821; border:1px solid #2a2f3b; border-radius:16px; padding:1rem; }
  .modal input { width:100%; background:#0c0d11; color:#e8eefa; border:1px solid #2a2f3b; border-radius:10px; padding:.6rem .7rem; font-family: ui-monospace, monospace; }
  .right { display:flex; gap:.5rem; justify-content:flex-end; }
</style>
</head>
<body>
  <header>
    <h1>JIS-BASICã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ï¼ˆFOR/NEXTãƒ»CSPå¯¾å¿œãƒ»INPUT/IFãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œï¼‰</h1>
    <button class="run"   id="btnRun">â–¶ å®Ÿè¡Œ</button>
    <button class="stop"  id="btnStop">â–  åœæ­¢</button>
    <button class="reset" id="btnReset">â†º ãƒªã‚»ãƒƒãƒˆ</button>
    <button class="clear" id="btnClear">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
    <button class="run"   id="btnStep">â­ 1è¡Œå®Ÿè¡Œ</button>
    <button class="run"   id="btnCont">â–¶ ç¶šè¡Œ</button>
    <label style="margin-left:.6rem">
      <input type="checkbox" id="chkStep"> ã‚¹ãƒ†ãƒƒãƒ—ON
    </label>
  </header>

  <div class="wrap">
    <div class="card">
      <h2>ğŸ“˜ ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿</h2>
      <div style="padding:1rem">
        <textarea id="editor" spellcheck="false">100 PRINT "ãƒ†ã‚¹ãƒˆé–‹å§‹"
110 LET S = 0
120 FOR I = 1 TO 5
130 LET S = S + I
140 NEXT I
150 IF S >= 15 THEN 180
160 PRINT "ã“ã“ã¯è¡¨ç¤ºã•ã‚Œãªã„ã¯ãš"
170 GOTO 190
180 PRINT "åˆè¨ˆ="; S
190 END</textarea>
        <div class="hint">
          å¯¾å¿œï¼š<code>PRINT</code>ï¼ˆ<code>,</code>ã¯14æ¡ã‚¿ãƒ–ã€<code>;</code>ã¯æ”¹è¡Œãªã—ï¼å¼è©•ä¾¡å¯ï¼‰ã€
          <code>INPUT [PROMPT "â€¦"] : å¤‰æ•°[,å¤‰æ•°â€¦]</code>ã€
          <code>LET/ä»£å…¥</code>ã€
          <code>IF â€¦ THEN â€¦</code>ï¼ˆå˜æ–‡ï¼‰ã€
          <code>IF â€¦ THEN</code>ï¼<code>ELSE</code>ï¼<code>END IF</code>ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã€
          <code>FOR â€¦ TO â€¦ [STEP â€¦]</code>ã€<code>NEXT</code>ã€
          <code>GOTO</code>ã€<code>END/STOP</code>ã€‚
        </div>
      </div>
    </div>

    <div class="card">
      <h2>ğŸ–¥ï¸ å®Ÿè¡Œç”»é¢</h2>
      <div style="padding:1rem"><div class="console" id="console"></div></div>
    </div>

    <div class="card">
      <h2>ğŸ” å¤‰æ•°ãƒ“ãƒ¥ãƒ¼</h2>
      <div style="padding:1rem">
        <table id="varsTable" style="width:100%; border-collapse:collapse; font-size:.9rem">
          <thead>
            <tr>
              <th style="text-align:left; border-bottom:1px solid #2a2f3b; padding:.25rem .4rem;">å¤‰æ•°</th>
              <th style="text-align:right;border-bottom:1px solid #2a2f3b; padding:.25rem .4rem;">å‰å›</th>
              <th style="text-align:right;border-bottom:1px solid #2a2f3b; padding:.25rem .4rem;">ç¾åœ¨</th>
              <th style="text-align:center;border-bottom:1px solid #2a2f3b; padding:.25rem .4rem;">å¤‰åŒ–</th>
            </tr>
          </thead>
          <tbody id="varsBody"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>ğŸ§­ ãƒˆãƒ¬ãƒ¼ã‚¹ï¼ˆè¡Œã”ã¨ã®å› æœï¼‰</h2>
      <div style="padding:1rem; max-height:280px; overflow:auto;">
        <div id="traceLog" style="font-family:ui-monospace,monospace; font-size:.9rem; line-height:1.5;"></div>
      </div>
    </div>
  </div>

  <!-- INPUT Modal -->
  <div class="modal" id="modal">
    <div class="panel">
      <div id="modalPrompt" style="margin:.25rem 0 .5rem 0">? </div>
      <input id="modalInput" placeholder="" />
      <div class="right" style="margin-top:.6rem">
        <button class="clear"  id="modalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button class="run"    id="modalOk">OK</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // ========== DOM ==========
  const con     = document.getElementById('console');
  const ed      = document.getElementById('editor');
  const chkStep = document.getElementById('chkStep');
  const btnStep = document.getElementById('btnStep');
  const btnCont = document.getElementById('btnCont');
  const varsBody= document.getElementById('varsBody');
  const traceLog= document.getElementById('traceLog');

  const modal        = document.getElementById('modal');
  const modalPrompt  = document.getElementById('modalPrompt');
  const modalInput   = document.getElementById('modalInput');
  const modalOk      = document.getElementById('modalOk');
  const modalCancel  = document.getElementById('modalCancel');

  // ========== çŠ¶æ…‹ ==========
  const initialCode = ed.value;
  let running=false, pc=0, vars={}, lineIndex={}, program=[];
  let loopStack=[];
  // ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
  let stepMode=false, waiting=false, lastVars = {};

  // ========== UI åŸºæœ¬ ==========
  function W(s){ con.textContent += s; con.scrollTop=con.scrollHeight; }
  function C(){ con.textContent=''; }
  function err(s){ W('âš ï¸ '+s+'\n'); }

  // ========== æ–‡å­—æ­£è¦åŒ– ==========
  function normalizeCode(src){
    src = src.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0)-0xFEE0));
    const map = {'ã€€':' ','â€œ':'"','â€':'"','â€':'"','â€Ÿ':'"','â€˜':"'",'â€™':"'",'â€š':"'",'â€¹':'<','â€º':'>','â‰¤':'<=','â‰¥':'>=','Ã—':'*','Ã·':'/','âˆ’':'-','ï¼Œ':',','ï¼›':';','ï¼š':':','\u3000':' '};
    src = src.replace(/[â€œâ€â€â€Ÿâ€˜â€™â€šâ€¹â€ºâ‰¤â‰¥Ã—Ã·âˆ’ï¼Œï¼›ï¼š\u3000]/g, ch => map[ch]||ch);
    src = src.replace(/[\u200B-\u200D\uFEFF]/g,'');
    return src;
  }
  function normalizeLine(s){
    if(!s) return "";
    s = s.replace(/^\uFEFF/,"");
    s = s.replace(/^[\uFEFF\u200B\u200C\u200D\u00A0\u3000]+/,"");
    s = s.replace(/^\t+/, m => " ".repeat(m.length));
    return s;
  }

  // ========== ãƒ¢ãƒ¼ãƒ€ãƒ«å…¥åŠ› ==========
  function ask(promptText,preset="",placeholder=""){
    modalPrompt.textContent = promptText || "?";
    modalInput.value = preset;
    modalInput.placeholder = placeholder || "å€¤ã‚’å…¥åŠ›";
    modal.style.display="flex";
    modalInput.focus();
    return new Promise((resolve,reject)=>{
      const cleanup = ()=>{ modal.style.display="none"; modalOk.onclick = modalCancel.onclick = modalInput.onkeydown = null; };
      modalOk.onclick = ()=>{ const v = modalInput.value; cleanup(); resolve(v); };
      modalCancel.onclick = ()=>{ cleanup(); reject(new Error("cancel")); };
      modalInput.onkeydown = (e)=>{ if(e.key==="Enter") modalOk.click(); if(e.key==="Escape") modalCancel.click(); };
    });
  }

  // ========== Tokenizer & Parser ==========
  function tokenize(s){
    const out=[]; let i=0;
    const isAlpha=c=>/[A-Za-z_]/.test(c), isAlnum=c=>/[A-Za-z0-9_]/.test(c);
    while(i<s.length){
      const ch=s[i];
      if(/\s/.test(ch)){ i++; continue; }
      if(ch=='"'){ let j=i+1,buf=''; while(j<s.length && s[j]!=='"'){ buf+=s[j++]; } j++; out.push({t:'str',v:buf}); i=j; continue; }
      if(/[0-9.]/.test(ch)){ let j=i,num='',dot=false; while(j<s.length && /[0-9.]/.test(s[j])){ if(s[j]==='.'&&dot) break; if(s[j]==='.') dot=true; num+=s[j++]; } out.push({t:'num',v:Number(num)}); i=j; continue; }
      if(isAlpha(ch)){ let j=i,id=''; while(j<s.length && isAlnum(s[j])) id+=s[j++]; const up=id.toUpperCase(); if(up==='AND'||up==='OR'){ out.push({t:'op',v:up}); } else { out.push({t:'id',v:up}); } i=j; continue; }
      const two=s.slice(i,i+2);
      if(['>=','<=','<>'].includes(two)){ out.push({t:'op',v:two}); i+=2; continue; }
      if('+-*/^=()<>'.includes(ch)){ if(ch==='('||ch===')') out.push({t:'par',v:ch}); else out.push({t:'op',v:ch}); i++; continue; }
      if(ch===','){ out.push({t:'comma'}); i++; continue; }
      throw new Error('æœªçŸ¥ã®æ–‡å­—: '+ch+' (U+'+ch.charCodeAt(0).toString(16).toUpperCase().padStart(4,'0')+')');
    }
    out.push({t:'eof'}); return out;
  }
  function evalExpr(expr){
    const tokens=tokenize(expr); let i=0;
    const peek=()=>tokens[i]||{t:'eof'}; const consume=()=>tokens[i++]||{t:'eof'};
    const toNum=v=> typeof v==='boolean'? (v?1:0) : (typeof v==='number'? v : Number(v));
    const parseExpr=()=>parseOr();
    function parseOr(){ let L=parseAnd(); while(peek().t==='op'&&peek().v==='OR'){ consume(); const R=parseAnd(); L=(toNum(L)||toNum(R))?1:0; } return L; }
    function parseAnd(){ let L=parseCmp(); while(peek().t==='op'&&peek().v==='AND'){ consume(); const R=parseCmp(); L=(toNum(L)&&toNum(R))?1:0; } return L; }
    function parseCmp(){ let L=parseAdd(); const p=peek(); if(p.t==='op'&&['=','<>','<','<=','>','>='].includes(p.v)){ consume(); const R=parseAdd(); switch(p.v){case '=':return (L==R)?1:0;case '<>':return (L!=R)?1:0;case '<':return (toNum(L)<toNum(R))?1:0;case '<=':return (toNum(L)<=toNum(R))?1:0;case '>':return (toNum(L)>toNum(R))?1:0;case '>=':return (toNum(L)>=toNum(R))?1:0;} } return L; }
    function parseAdd(){ let L=parseMul(); while(peek().t==='op'&&(peek().v==='+'||peek().v==='-')){ const op=consume().v; const R=parseMul(); L=(op==='+')? toNum(L)+toNum(R) : toNum(L)-toNum(R); } return L; }
    function parseMul(){ let L=parsePow(); while(peek().t==='op'&&(peek().v==='*'||peek().v==='/')){ const op=consume().v; const R=parsePow(); L=(op==='*')? toNum(L)*toNum(R) : toNum(L)/toNum(R); } return L; }
    function parsePow(){ let L=parseUnary(); while(peek().t==='op'&&peek().v==='^'){ consume(); const R=parseUnary(); L=Math.pow(toNum(L), toNum(R)); } return L; }
    function parseUnary(){ const p=peek(); if(p.t==='op'&&(p.v==='+'||p.v==='-')){ consume(); const v=parseUnary(); return p.v==='-'? -toNum(v) : toNum(v); } return parsePrimary(); }
    function parsePrimary(){
      const t=peek();
      if(t.t==='num'){ consume(); return t.v; }
      if(t.t==='str'){ consume(); return t.v; }
      if(t.t==='id'){ const name=t.v; consume(); return getVar(name); }
      if(t.t==='par'&&t.v==='('){ consume(); const v=parseExpr(); if(peek().t!=='par'||peek().v!==')') throw new Error(')ãŒå¿…è¦'); consume(); return v; }
      throw new Error('å¼ã‚¨ãƒ©ãƒ¼');
    }
    return parseExpr();
  }

  // ========== å¤‰æ•° ==========
  function toKey(s){ return s.toUpperCase(); }
  function getVar(n){ return (n=toKey(n), vars[n]??0); }
  function setVar(n,v){ vars[toKey(n)]=v; }

  // ========== ãƒ—ãƒ­ã‚°ãƒ©ãƒ è§£æ ==========
  function parseProgram(src){
    src = src.replace(/^\uFEFF/,"");
    const raw=src.split(/\r?\n/); program=[]; lineIndex={};
    for(const r of raw){
      const line = normalizeLine(r);
      if(!line.trim()) continue;
      const m=line.match(/^(\d+)\s+(.*)$/);
      if(!m) throw new Error('è¡Œç•ªå·ãŒå¿…è¦: '+line);
      program.push({ln:parseInt(m[1],10), text:m[2].trim()});
    }
    program.sort((a,b)=>a.ln-b.ln);
    program.forEach((st,i)=> lineIndex[st.ln]=i);
  }

  // ========== EXEC 1è¡Œ ==========
  async function execLine(idx){
    const {ln,text}=program[idx];
    const up=text.toUpperCase();

    if(/^REM/.test(up)) return;
    if(/^(END|STOP)$/.test(up)) { running=false; return; }

    // PRINT
    if(/^PRINT\b/i.test(up)){
      const body=text.replace(/^PRINT\s*/i,'');
      const parts=[]; let buf='', inStr=false, depth=0;
      for(let i=0;i<body.length;i++){
        const c=body[i];
        if(c==='"'){ inStr=!inStr; buf+=c; continue; }
        if(!inStr){
          if(c==='('){ depth++; buf+=c; continue; }
          if(c===')'){ depth--; buf+=c; continue; }
          if((c===','||c===';')&&depth===0){ parts.push({expr:buf.trim(),sep:c}); buf=''; continue; }
        }
        buf+=c;
      }
      parts.push({expr:buf.trim(),sep:null});
      let lineOut='',col=0,lastSep=null;
      for(const p of parts){
        if(p.expr.length>0){
          const v=evalExpr(p.expr);
          const s=(typeof v==='string')? v : String(v);
          lineOut+=s; col+=s.length;
        }
        lastSep=p.sep;
        if(p.sep===','){
          const zone=14; const rem = col%zone; const pad=(rem===0)?zone:(zone-rem);
          lineOut+=' '.repeat(pad); col+=pad;
        }
      }
      W(lineOut+(lastSep===';'?'':'\n'));
      return;
    }

    // IF THENï¼ˆãƒ–ãƒ­ãƒƒã‚¯ï¼‰
    let mIfBlk = text.match(/^IF\s+(.+?)\s+THEN\s*$/i);
    if(mIfBlk){
      const cond = !!evalExpr(mIfBlk[1]);
      let depth=0, elseIdx=-1, endIdx=-1;
      for(let j=idx+1;j<program.length;j++){
        const uj=program[j].text.toUpperCase().trim();
        if(/^IF\s+.+\s+THEN\s*$/.test(uj)){ depth++; continue; }
        if(/^END\s+IF$/.test(uj)){ if(depth===0){endIdx=j; break;} else {depth--; continue;} }
        if(/^ELSE$/.test(uj)){ if(depth===0 && elseIdx<0) elseIdx=j; }
      }
      if(endIdx<0) throw new Error('IF ã«å¯¾å¿œã™ã‚‹ END IF ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      if(!cond) pc = (elseIdx>=0 ? elseIdx : endIdx) - 1;
      return;
    }
    if(/^ELSE$/i.test(up.trim())){
      let depth=0, endIdx=-1;
      for(let j=idx+1;j<program.length;j++){
        const uj=program[j].text.toUpperCase().trim();
        if(/^IF\s+.+\s+THEN\s*$/.test(uj)){ depth++; continue; }
        if(/^END\s+IF$/.test(uj)){ if(depth===0){ endIdx=j; break; } else { depth--; continue; } }
      }
      if(endIdx<0) throw new Error('ELSE ã«å¯¾å¿œã™ã‚‹ END IF ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      pc=endIdx-1; return;
    }
    if(/^END\s+IF$/i.test(up.trim())){ return; }

    // INPUT
    if(/^INPUT\b/i.test(up)){
      let promptTxt="?", varPart=null, m;
      m = text.match(/^INPUT\s+PROMPT\s+"([^"]*)"\s*:\s*(.+)$/i);
      if(m){ promptTxt=m[1]; varPart=m[2]; }
      else{
        m=text.match(/^INPUT\s+(.+)$/i);
        if(m){ varPart=m[1]; }
      }
      if(!varPart) throw new Error("INPUT æ§‹æ–‡ã‚¨ãƒ©ãƒ¼");

      const names = varPart.split(/\s*,\s*/);
      const placeholder = (names.length===1)? "ä¾‹: 1" : "ä¾‹: " + names.map((_,i)=>i+1).join(", ");

      while(true){
        const ans = await ask(promptTxt,"",placeholder);
        const values = ans.split(/\s*,\s*/);
        if(values.length < names.length){ err("å…¥åŠ›ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"); continue; }
        let ok=true; const parsed=[];
        for(let i=0;i<names.length;i++){
          const raw=(values[i]??"").trim(); if(raw===""){ok=false;break;}
          const num=Number(raw); if(Number.isNaN(num)){ok=false;break;}
          parsed.push(num);
        }
        if(!ok){ err("æ•°å€¤ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ã®å½¢å¼ã«å¾“ã£ã¦å†å…¥åŠ›ã‚’ã€‚"); continue; }
        for(let i=0;i<names.length;i++){ setVar(names[i].toUpperCase(), parsed[i]); }
        break;
      }
      return;
    }

    // LET / ä»£å…¥
    if(/^LET\b/i.test(up)||/^[A-Z]/.test(text)){
      const m=text.replace(/^LET\s+/i,'').match(/^([A-Z][A-Z0-9_]*)\s*=\s*(.+)$/i);
      if(m){ setVar(m[1], evalExpr(m[2])); return; }
    }

    // FOR
    let mf=text.match(/^FOR\s+([A-Z][A-Z0-9_]*)\s*=\s*(.+?)\s+TO\s+(.+?)(?:\s+STEP\s+(.+))?\s*$/i);
    if(mf){
      const v=mf[1], init=Number(evalExpr(mf[2])), fin=Number(evalExpr(mf[3]));
      const step=(mf[4]!=null)? Number(evalExpr(mf[4])) : 1;
      if(!isFinite(init)||!isFinite(fin)||!isFinite(step)) throw new Error('FORã®å€¤ãŒæ•°å€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
      if(step===0) throw new Error('STEP ã¯ 0 ã«ã§ãã¾ã›ã‚“');
      setVar(v, init);
      let depth=0, nextIndex=-1;
      for(let j=idx+1;j<program.length;j++){
        const u=program[j].text.toUpperCase();
        if(/^FOR\b/.test(u)) depth++;
        if(/^NEXT\b/.test(u)){ if(depth===0){ nextIndex=j; break; } else depth--; }
      }
      if(nextIndex<0) throw new Error('FOR ã«å¯¾å¿œã™ã‚‹ NEXT ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      const exec=(step>0)?(init<=fin):(init>=fin);
      if(!exec){ pc=nextIndex; return; }
      loopStack.push({var:v, fin, step, start:idx+1, forIndex:idx, nextIndex});
      return;
    }

    // NEXT
    let mn=text.match(/^NEXT\s*([A-Z][A-Z0-9_]*)?\s*$/i);
    if(mn){
      if(loopStack.length===0) throw new Error('NEXT ã«å¯¾å¿œã™ã‚‹ FOR ãŒã‚ã‚Šã¾ã›ã‚“');
      const ctx=loopStack[loopStack.length-1];
      if(mn[1] && mn[1].toUpperCase()!==ctx.var) throw new Error('NEXT '+mn[1]+' ã¯ FOR '+ctx.var+' ã¨ä¸€è‡´ã—ã¾ã›ã‚“');
      const nv=Number(getVar(ctx.var)) + ctx.step;
      setVar(ctx.var,nv);
      const cont=(ctx.step>0)?(nv<=ctx.fin):(nv>=ctx.fin);
      if(cont) pc=ctx.start-1; else loopStack.pop();
      return;
    }

    // GOTO
    let mg=text.match(/^GOTO\s+(\d+)\s*$/i);
    if(mg){ const t=+mg[1]; if(lineIndex[t]==null) throw new Error('è¡Œ '+t+' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); pc=lineIndex[t]-1; return; }

    // IF ... THEN å˜æ–‡ï¼ˆGOTOè¡Œç•ªå· ã¾ãŸã¯ å˜æ–‡ï¼‰
    let mIf=text.match(/^IF\s+(.+?)\s+THEN\s+(.+)$/i);
    if(mIf){
      const cond=!!evalExpr(mIf[1]);
      if(cond){
        const stmt=mIf[2].trim();
        if(/^\d+$/.test(stmt)){ const t=+stmt; if(lineIndex[t]==null) throw new Error('è¡Œ '+t+' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); pc=lineIndex[t]-1; }
        else{
          const tmp={ ln, text:stmt }; program.splice(idx+1,0,tmp);
          for(const k in lineIndex){ if(lineIndex[k]>idx) lineIndex[k]++; }
        }
      }
      return;
    }

    throw new Error('æœªçŸ¥ã®æ–‡: '+text);
  }

  // ========== ãƒ•ãƒ«å®Ÿè¡Œ ==========
  async function runAll(){
    stepMode=false; waiting=false; // é€šå¸¸å®Ÿè¡Œ
    C(); traceLog.innerHTML=''; vars={}; loopStack=[]; pc=0; running=true; W('ğŸš€ ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œé–‹å§‹\n');
    try{ parseProgram(normalizeCode(ed.value)); }catch(e){ err('æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: '+e.message); return; }
    lastVars = {};
    while(running && pc<program.length){
      try{
        const before = snapshot(vars);
        const prevPc = pc;
        await execLine(pc);
        pc++;
        const after = snapshot(vars);
        updateVarsUI(after, diffVars(before, after));
        logTrace({ln:program[prevPc].ln, text:program[prevPc].text, diff:diffVars(before, after)});
      }catch(e){ err('å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ï¼ˆè¡Œ '+program[pc].ln+'ï¼‰: '+e.message); running=false; }
      if(pc>100000){ err('å®Ÿè¡ŒãŒé•·ã™ãã¾ã™ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—ï¼Ÿï¼‰'); running=false; }
    }
  }

  // ========== ã‚¹ãƒ†ãƒƒãƒ—ç³» ==========
  chkStep.addEventListener('change', ()=> stepMode = chkStep.checked);

  btnStep.addEventListener('click', async ()=>{
    if(!program || program.length===0 || !running){
      // åˆå›ï¼ˆã¾ãŸã¯åœæ­¢å¾Œï¼‰åˆæœŸåŒ–
      C(); traceLog.innerHTML=''; vars={}; loopStack=[]; pc=0; running=true; W('ğŸš€ ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œé–‹å§‹\n');
      try{ parseProgram(normalizeCode(ed.value)); }catch(e){ err('æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: '+e.message); return; }
      lastVars = {};
    }
    await stepOnce();
  });

  btnCont.addEventListener('click', async ()=>{
    if(!program || program.length===0 || !running){
      C(); traceLog.innerHTML=''; vars={}; loopStack=[]; pc=0; running=true; W('ğŸš€ ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œé–‹å§‹\n');
      try{ parseProgram(normalizeCode(ed.value)); }catch(e){ err('æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: '+e.message); return; }
      lastVars = {};
    }
    waiting=false;
    while(stepMode && !waiting && running && pc<program.length){
      await stepOnce(true);
    }
  });

  async function stepOnce(noStop){
    stepMode=true; chkStep.checked=true;

    if(pc >= program.length){ logTrace({ln:null, text:'<END>', note:'ãƒ—ãƒ­ã‚°ãƒ©ãƒ çµ‚äº†'}); running=false; return; }

    const before = snapshot(vars);
    const prevPc = pc;
    try{ await execLine(pc); }catch(e){}
    pc++;
    const after = snapshot(vars);
    const diff = diffVars(before, after);
    focusLine(program[prevPc].ln);
    updateVarsUI(after, diff);
    logTrace({ln:program[prevPc].ln, text:program[prevPc].text, diff});

    // åœæ­¢ãƒ•ãƒ©ã‚°
    waiting = !noStop;
  }

  // ========== å¤‰æ•°ãƒ“ãƒ¥ãƒ¼ï¼ãƒˆãƒ¬ãƒ¼ã‚¹ ==========
  function snapshot(obj){ const out={}; for(const k of Object.keys(obj||{})) out[k]=obj[k]; return out; }
  function diffVars(before, after){
    const keys = new Set([...Object.keys(before), ...Object.keys(after)]);
    const out=[];
    for(const k of keys){
      const b=before[k], a=after[k];
      if(b!==a){ out.push({name:k, old:b, now:a}); }
    }
    return out.sort((x,y)=>x.name.localeCompare(y.name));
  }

  function updateVarsUI(curVars, changes){
    const keys = new Set([...Object.keys(lastVars), ...Object.keys(curVars)]);
    const rows=[];
    keys.forEach(k=>{
      const b=lastVars[k], a=curVars[k];
      const changed=(b!==a);
      rows.push(`
        <tr class="${changed?'changed':''}">
          <td style="padding:.15rem .4rem">${k}</td>
          <td style="text-align:right; padding:.15rem .4rem">${printVal(b)}</td>
          <td style="text-align:right; padding:.15rem .4rem">${printVal(a)}</td>
          <td style="text-align:center; padding:.15rem .4rem">${changed?dirMark(b,a):''}</td>
        </tr>
      `);
    });
    varsBody.innerHTML = rows.join('');
    lastVars = snapshot(curVars);
    setTimeout(()=>{ for(const tr of varsBody.querySelectorAll('.changed')) tr.classList.remove('changed'); },900);
  }
  function dirMark(b,a){ if(typeof b==='number' && typeof a==='number'){ return a>b?'â†‘':(a<b?'â†“':'='); } return 'â†”'; }
  function printVal(v){ if(v===undefined) return ''; if(typeof v==='string') return '"'+v+'"'; return String(v); }

  function logTrace({ln, text, diff, note}){
    const lnStr = (ln==null)?'(END)':(`è¡Œ ${ln}`);
    const code  = (text!=null)? escapeHtml(text) : '';
    const diffs = (diff && diff.length>0)? ' / å¤‰æ›´: ' + diff.map(d=>`${d.name}:${printVal(d.old)}â†’${printVal(d.now)}`).join(', ') : '';
    const noteStr= note? `<span class="trace-note">${escapeHtml(note)}</span>` : '';
    const diffStr= diffs? `<span class="trace-diff">${escapeHtml(diffs)}</span>` : '';
    const line=document.createElement('div');
    line.className='trace-line';
    line.innerHTML=`<b>${lnStr}</b>  ${code} ${noteStr}${diffStr}`;
    traceLog.appendChild(line);
    traceLog.scrollTop=traceLog.scrollHeight;
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // ========== ã‚¨ãƒ‡ã‚£ã‚¿ä¸Šã®è©²å½“è¡Œã¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼†é¸æŠ ==========
  function focusLine(ln){
    if(!ln) return;
    const lines = ed.value.split(/\r?\n/);
    let pos=0;
    for(const line of lines){
      const m=line.match(/^(\d+)\s+/);
      if(m && Number(m[1])===ln){
        const start=pos, end=pos+line.length;
        ed.focus();
        if(ed.setSelectionRange) ed.setSelectionRange(start,end);
        ed.scrollTop = lineTop(ed, start);
        return;
      }
      pos += line.length+1;
    }
  }
  function lineTop(textarea, index){
    const upto=textarea.value.slice(0,index);
    const lines=upto.split(/\r?\n/).length;
    const lineHeight=18;
    return Math.max(0,(lines-5)*lineHeight);
  }

  // ========== ãƒœã‚¿ãƒ³é…ç·š ==========
  document.getElementById('btnRun').onclick  = ()=>{ if(!running) runAll(); };
  document.getElementById('btnStop').onclick = ()=> running=false;
  document.getElementById('btnReset').onclick= ()=>{ running=false; ed.value=initialCode; C(); traceLog.innerHTML=''; W('ğŸ”„ ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ\n'); };
  document.getElementById('btnClear').onclick= ()=>{ running=false; ed.value=''; C(); traceLog.innerHTML=''; W('ğŸ§¹ ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼ˆæ–°ã—ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼‰\n'); };

})();
</script>
</body>
</html>
