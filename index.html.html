<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JIS-BASICエミュレータ（FOR/NEXT・CSP対応・INPUT/IFブロック対応）</title>

<style>
:root{
  --hdr: 56px;              /* ヘッダー高さ（必要なら微調整） */
  --gap: 12px;
  color-scheme: dark;
}

*{ box-sizing: border-box; }
html,body{ height:100%; }

body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
    "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", "Meiryo", sans-serif;
  background:#0b0b0c; color:#e7ecef;
}

/* ── ヘッダー（高さ固定） ───────────────────────── */
header{
  height:var(--hdr);
  display:flex; align-items:center; gap:.6rem;
  padding:0 12px; border-bottom:1px solid #202632;
  background:linear-gradient(180deg, rgba(16,18,24,.96), rgba(16,18,24,.92));
  position:sticky; top:0; z-index:100;
}
h1{ font-size:1.05rem; margin:0 .6rem 0 0; font-weight:800; letter-spacing:.01em; }

/* ボタン */
button{
  border:0; border-radius:14px; padding:.58rem .9rem; font-weight:700; cursor:pointer;
  color:#0a0d12; user-select:none;
}
.btn{ display:inline-flex; gap:.35rem; align-items:center; }
.btn.run   { background:#28d17c; }
.btn.stop  { background:#ff5c5c; color:#2b0707; }
.btn.reset { background:#6aa8ff; color:#041427; }
.btn.clear { background:#ffc55c; }
.btn.step1 { background:#c39bff; color:#1b0f2b; }
.btn.cont  { background:#90e0ef; color:#062a2e; }
.btn:disabled{ opacity:.5; cursor:not-allowed; }

/* 右上のカウンタ */
.countArea{ margin-left:auto; display:flex; align-items:center; gap:.7rem; opacity:.95; }
.countArea .chip{
  background:#1a2230; border:1px solid #2a3344; border-radius:12px; padding:.35rem .55rem;
  font-size:.9rem; color:#cfe1ff;
}

/* ── メイン領域：1 画面に固定 ─────────────────────── */
.wrap{
  height: calc(100vh - var(--hdr));
  width: 100%;
  max-width: 1400px;
  margin: 0 auto;
  padding: var(--gap);
  display: grid;
  grid-template-columns: minmax(560px, 1fr) 420px; /* 左右比 1 : 420px */
  gap: var(--gap);
  overflow: hidden;
}

/* 左右の列は内部で縦分割（それぞれ独立スクロール） */
.leftPane{
  height:100%;
  display:grid;
  grid-template-rows: 1fr 200px;        /* エディタ / 実行画面 */
  gap: var(--gap);
  overflow: hidden;
}
.rightPane{
  height:100%;
  display:grid;
  grid-template-rows: 220px 1fr;        /* 変数 / トレース */
  gap: var(--gap);
  overflow: hidden;
}

/* カード & タイトル */
.card{
  background:#0e1726; border:1px solid #1f2330; border-radius:12px;
  box-shadow:0 0 0 1px rgba(255,255,255,.03) inset;
  height:100%; display:flex; flex-direction:column; overflow:hidden;
}
.card h2{
  margin:0; padding:.6rem .8rem; font-size:.92rem; border-bottom:1px solid #1f2330;
  display:flex; align-items:center; gap:.45rem;
}

.card .bodyScroll{ flex:1 1 auto; overflow:auto; padding:.8rem; }

/* エリア色（薄め） */
.card.editor     { background:#0e1726; }
.card.consoleWrap{ background:#0f1f1a; }
.card.vars       { background:#181328; }
.card.trace      { background:#261a10; }

/* エディタ/コンソール */
textarea{
  width:100%; height:100%; box-sizing:border-box;
  background:#0b1020; color:#e9f1ff; border:1px solid #38486a; border-radius:10px;
  padding:.85rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size:14px; line-height:1.55;
}
textarea:focus{ outline:none; box-shadow:0 0 0 2px #4b6eb1; border-color:#4b6eb1; }

.console{
  width:100%; height:100%; box-sizing:border-box;
  background:#000; color:#38f08f; border:1px solid #274c40; border-radius:10px;
  padding:.85rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size:13.5px; white-space:pre-wrap; overflow:auto;
}

/* 変数ビューの表 */
table{ width:100%; border-collapse:collapse; font-size:.92rem; }
th, td{ border-bottom:1px solid #2a2f3b; padding:.42rem .55rem; }
th{ text-align:left; opacity:.9; }
td.num{ text-align:right; }
.changed{ background: rgba(234,179,8,.18); transition:background 1.2s ease; }

/* トレース行 */
.traceRow{
  border-left:3px solid #eab308; padding:.22rem .55rem; margin:.14rem 0;
  font-family: ui-monospace, monospace; font-size:.95rem; background:rgba(255,255,255,.02);
  border-radius:6px;
}
.trace-diff{ color:#eab308; margin-left:.4rem; font-size:.86rem; }
.trace-note{ color:#8ab4f8; margin-left:.4rem; font-size:.86rem; }

/* モーダル（INPUT用） */
.modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center;
  background:rgba(0,0,0,.65); z-index:300; }
.modal .panel{ width:min(92vw, 520px); background:#161821; border:1px solid #2a2f3b;
  border-radius:16px; padding:1rem; }
.modal input{ width:100%; background:#0c0d11; color:#e8eefa; border:1px solid #2a2f3b;
  border-radius:10px; padding:.6rem .7rem; font-family: ui-monospace, monospace; }
.modal .right{ display:flex; gap:.5rem; justify-content:flex-end; margin-top:.6rem; }

/* レスポンシブ */
@media (max-width: 1100px){
  .wrap{ grid-template-columns: 1fr; max-width: 100vw; }
  .leftPane{ grid-template-rows: 1fr 220px; }
  .rightPane{ grid-template-rows: 220px 1fr; }
}
</style>
</head>
<body>

<header>
  <h1>JIS-BASICエミュレータ</h1>

  <button class="btn run"   id="btnRun">▶ 実行</button>
  <button class="btn stop"  id="btnStop">■ 停止</button>
  <button class="btn reset" id="btnReset">↺ リセット</button>
  <button class="btn clear" id="btnClear">🧹 クリア</button>
  <button class="btn step1" id="btnStep">⏩ 1行実行</button>
  <button class="btn cont"  id="btnCont">▶ 続行</button>

  <label style="display:flex;align-items:center;gap:.4rem;margin-left:.6rem;opacity:.95">
    <input type="checkbox" id="chkStep"> ステップON
  </label>

  <div class="countArea">
    <span class="chip">👥 <span id="countToday">今日 0</span> / <span id="countTotal">累計 0</span></span>
  </div>
</header>

<div class="wrap">
  <!-- 左列：エディタ＋実行画面 -->
  <div class="leftPane">
    <div class="card editor">
      <h2>📘 コードエディタ</h2>
      <div class="bodyScroll">
        <textarea id="editor" spellcheck="false"></textarea>
      </div>
    </div>

    <div class="card consoleWrap">
      <h2>🖥️ 実行画面</h2>
      <div class="bodyScroll"><div class="console" id="console"></div></div>
    </div>
  </div>

  <!-- 右列：変数ビュー＋トレース -->
  <div class="rightPane">
    <div class="card vars">
      <h2>🔎 変数ビュー</h2>
      <div class="bodyScroll">
        <table>
          <thead>
            <tr>
              <th>変数</th>
              <th class="num">前回</th>
              <th class="num">現在</th>
              <th style="text-align:center">変化</th>
            </tr>
          </thead>
          <tbody id="varsBody"></tbody>
        </table>
      </div>
    </div>

    <div class="card trace">
      <h2>⏱ トレース（行ごとの因果）</h2>
      <div class="bodyScroll"><div id="traceLog"></div></div>
    </div>
  </div>
</div>

<!-- INPUT Modal -->
<div class="modal" id="modal">
  <div class="panel">
    <div id="modalPrompt" style="margin:.25rem 0 .5rem 0">? </div>
    <input id="modalInput" placeholder="値を入力" />
    <div class="right">
      <button class="btn clear"  id="modalCancel">キャンセル</button>
      <button class="btn run"    id="modalOk">OK</button>
    </div>
  </div>
</div>

<script>
/* ============================================================
   0) ユーザカウンタ（今日/累計）
   ============================================================ */
(function countUsers(){
  const todayKey = 'jis_basic_counter_today_date';
  const todayCnt = 'jis_basic_counter_today';
  const totalCnt = 'jis_basic_counter_total';
  const todayStr = new Date().toISOString().slice(0,10);

  let last = localStorage.getItem(todayKey);
  if (last !== todayStr) {
    localStorage.setItem(todayKey, todayStr);
    localStorage.setItem(todayCnt, String(0));
  }
  // ページ訪問1回をカウント（重複を避けたいときはセッションフラグで制御）
  if (!sessionStorage.getItem('jis_basic_visit')) {
    sessionStorage.setItem('jis_basic_visit', '1');
    localStorage.setItem(todayCnt, String((+localStorage.getItem(todayCnt)||0)+1));
    localStorage.setItem(totalCnt, String((+localStorage.getItem(totalCnt)||0)+1));
  }
  const tp = document.getElementById('countToday');
  const tt = document.getElementById('countTotal');
  tp.textContent = `今日 ${+localStorage.getItem(todayCnt)||0}`;
  tt.textContent = `累計 ${+localStorage.getItem(totalCnt)||0}`;
})();

/* ============================================================
   1) 参照・UI
   ============================================================ */
const ed  = document.getElementById('editor');
const con = document.getElementById('console');
const chkStep = document.getElementById('chkStep');
const btnStep = document.getElementById('btnStep');
const btnCont = document.getElementById('btnCont');
const varsBody = document.getElementById('varsBody');
const traceLog = document.getElementById('traceLog');

const modal        = document.getElementById('modal');
const modalPrompt  = document.getElementById('modalPrompt');
const modalInput   = document.getElementById('modalInput');
const modalOk      = document.getElementById('modalOk');
const modalCancel  = document.getElementById('modalCancel');

// コンソール
function W(s){ con.textContent += s; con.scrollTop=con.scrollHeight; }
function C(){ con.textContent=''; }
function err(s){ W('⚠️ '+s+'\n'); }

/* ============================================================
   2) サンプル自動復元／自動保存
   ============================================================ */
const SAMPLE_CODE =
`100 PRINT "テスト開始"
110 LET S = 0
120 FOR I = 1 TO 5
130 LET S = S + I
140 NEXT I
150 IF S >= 15 THEN 180
160 PRINT "ここは表示されないはず"
170 GOTO 190
180 PRINT "合計="; S
190 END`;

(function initSample(){
  const k='jis_basic_last_code';
  const saved=localStorage.getItem(k);
  ed.value = saved && saved.trim() ? saved : SAMPLE_CODE;
  ed.addEventListener('keyup',()=>localStorage.setItem(k, ed.value));
  window.addEventListener('beforeunload',()=>localStorage.setItem(k, ed.value));
})();

/* ============================================================
   3) 実行系（パーサ・式評価・命令）
   ============================================================ */
let running=false, stepMode=false, waiting=false;
let program=[], lineIndex={}, pc=0, vars={}, lastVars={}, loopStack=[];

function resetState(){
  running=false; stepMode=false; waiting=false;
  program=[]; lineIndex={}; pc=0; vars={}; lastVars={}; loopStack=[];
}

function normalizeCode(src){
  // 全角→半角 和製スマート引用なども排除
  src = src.replace(/[\uFF01-\uFF5E]/g, ch =>
    String.fromCharCode(ch.charCodeAt(0)-0xFEE0));
  const map = {'　':' ','“':'"','”':'"','„':'"','‟':'"','‘':"'",'’':"'",'‚':"'",'‹':'<','›':'>','≤':'<=','≥':'>=','×':'*','÷':'/','−':'-','，':',','；':';','：':':','\u3000':' '};
  src = src.replace(/[“”„‟‘’‚‹›≤≥×÷−，；：\u3000]/g, ch=>map[ch]||ch);
  src = src.replace(/[\u200B-\u200D\uFEFF]/g,'');
  return src;
}
function normalizeLine(s){
  if(!s) return '';
  s = s.replace(/^\uFEFF/,'');
  s = s.replace(/^[\uFEFF\u200B\u200C\u200D\u00A0\u3000]+/,'');
  s = s.replace(/^\t+/,m=>' '.repeat(m.length));
  return s;
}

function parseProgram(src){
  const raw=normalizeCode(src).split(/\r?\n/);
  program=[]; lineIndex={};
  for(const r of raw){
    const line=normalizeLine(r);
    if(!line.trim()) continue;
    const m=line.match(/^(\d+)\s+(.*)$/);
    if(!m) throw new Error('行番号が必要: '+line);
    program.push({ln:+m[1], text:m[2].trim()});
  }
  program.sort((a,b)=>a.ln-b.ln);
  program.forEach((st,i)=>lineIndex[st.ln]=i);
}

/* ---------- トークナイザ & 式評価（関数対応） ---------- */
function tokenize(s){
  const out=[]; let i=0;
  const isAlpha=c=>/[A-Za-z_]/.test(c), isAlnum=c=>/[A-Za-z0-9_]/.test(c);
  while(i<s.length){
    const ch=s[i];
    if(/\s/.test(ch)){ i++; continue; }
    if(ch=='"'){ let j=i+1, buf=''; while(j<s.length && s[j]!=='"'){ buf+=s[j++]; } j++; out.push({t:'str',v:buf}); i=j; continue; }
    if(/[0-9.]/.test(ch)){ let j=i, num='', dot=false; while(j<s.length && /[0-9.]/.test(s[j])){ if(s[j]==='.'&&dot) break; if(s[j]==='.') dot=true; num+=s[j++]; } out.push({t:'num',v:Number(num)}); i=j; continue; }
    if(isAlpha(ch)){ let j=i, id=''; while(j<s.length && isAlnum(s[j])) id+=s[j++]; const up=id.toUpperCase(); if(up==='AND'||up==='OR'){ out.push({t:'op',v:up}); } else { out.push({t:'id',v:up}); } i=j; continue; }
    const two=s.slice(i,i+2);
    if(['>=','<=','<>'].includes(two)){ out.push({t:'op',v:two}); i+=2; continue; }
    if('+-*/^=()<>,' .includes(ch)){ if(ch==='('||ch===')') out.push({t:'par',v:ch}); else if(ch===',') out.push({t:'comma'}); else out.push({t:'op',v:ch}); i++; continue; }
    throw new Error('未知の文字: '+ch+' (U+'+ch.charCodeAt(0).toString(16).padStart(4,'0')+')');
  }
  out.push({t:'eof'}); return out;
}
function toNum(v){ return typeof v==='boolean' ? (v?1:0) : (typeof v==='number'? v : Number(v)); }

function evalExpr(expr){
  const tokens=tokenize(expr); let i=0;
  const peek=()=>tokens[i]||{t:'eof'}; const consume=()=>tokens[i++]||{t:'eof'};

  const parseExpr=()=>parseOr();
  function parseOr(){ let L=parseAnd(); while(peek().t==='op'&&peek().v==='OR'){ consume(); const R=parseAnd(); L=(toNum(L)||toNum(R))?1:0; } return L; }
  function parseAnd(){ let L=parseCmp(); while(peek().t==='op'&&peek().v==='AND'){ consume(); const R=parseCmp(); L=(toNum(L)&&toNum(R))?1:0; } return L; }
  function parseCmp(){ let L=parseAdd(); const p=peek(); if(p.t==='op'&&['=','<>','<','<=','>','>='].includes(p.v)){ consume(); const R=parseAdd(); switch(p.v){case '=':return (L==R)?1:0;case '<>':return (L!=R)?1:0;case '<':return (toNum(L)<toNum(R))?1:0;case '<=':return (toNum(L)<=toNum(R))?1:0;case '>':return (toNum(L)>toNum(R))?1:0;case '>=':return (toNum(L)>=toNum(R))?1:0;} } return L; }
  function parseAdd(){ let L=parseMul(); while(peek().t==='op'&&(peek().v==='+'||peek().v==='-')){ const op=consume().v; const R=parseMul(); L=(op==='+')? toNum(L)+toNum(R) : toNum(L)-toNum(R); } return L; }
  function parseMul(){ let L=parsePow(); while(peek().t==='op'&&(peek().v==='*'||peek().v=='/')){ const op=consume().v; const R=parsePow(); L=(op==='*')? toNum(L)*toNum(R) : toNum(L)/toNum(R); } return L; }
  function parsePow(){ let L=parseUnary(); while(peek().t==='op'&&peek().v==='^'){ consume(); const R=parseUnary(); L=Math.pow(toNum(L), toNum(R)); } return L; }
  function parseUnary(){ const p=peek(); if(p.t==='op'&&(p.v==='+'||p.v==='-')){ consume(); const v=parseUnary(); return p.v==='-'? -toNum(v):toNum(v);} return parsePrimary(); }

  function parsePrimary(){
    const t=peek();
    if(t.t==='num'){ consume(); return t.v; }
    if(t.t==='str'){ consume(); return t.v; }
    if(t.t==='id'){
      const name=t.v; consume();
      // 関数呼び出し？
      if(peek().t==='par' && peek().v==='('){
        consume(); // (
        const args=[];
        while(peek().t!=='par' || peek().v!==')'){
          args.push(parseExpr());
          if(peek().t==='comma') consume();
          else if(peek().t==='par' && peek().v===')') break;
          else if(peek().t==='eof') throw new Error(') が必要');
        }
        consume(); // )
        return callFunc(name,args);
      }
      return getVar(name);
    }
    if(t.t==='par'&&t.v==='('){ consume(); const v=parseExpr(); if(peek().t!=='par'||peek().v!==')') throw new Error(')が必要'); consume(); return v; }
    throw new Error('式エラー');
  }

  function callFunc(name,args){
    switch(name){
      case 'ABS':  return Math.abs(toNum(args[0]??0));
      case 'SQR':  return Math.sqrt(toNum(args[0]??0));
      case 'INT':  return Math.trunc(toNum(args[0]??0));
      case 'MOD': { const a=toNum(args[0]??0), b=toNum(args[1]??1); return ((a%b)+b)%b; }
      case 'SIN':  return Math.sin(toNum(args[0]??0));
      case 'COS':  return Math.cos(toNum(args[0]??0));
      case 'TAN':  return Math.tan(toNum(args[0]??0));
      case 'ATN':  return Math.atan(toNum(args[0]??0));
      case 'PI':   return Math.PI;
      case 'LOG':  return Math.log(toNum(args[0]??1));
      case 'LOG10':return Math.log10(toNum(args[0]??1));
      case 'EXP':  return Math.exp(toNum(args[0]??0));
      case 'RND':  return Math.random();
      default: throw new Error('未対応関数: '+name);
    }
  }
  return parseExpr();
}

/* ---------- 変数 ---------- */
function toKey(s){ return s.toUpperCase(); }
function getVar(n){ return (n=toKey(n), vars[n]??0); }
function setVar(n,v){ vars[toKey(n)]=v; }

/* ---------- 変数ビュー & トレース ---------- */
function snapshot(obj){ const out={}; for(const k of Object.keys(obj||{})) out[k]=obj[k]; return out; }
function dirMark(b,a){ if(typeof b==='number' && typeof a==='number'){ return a>b?'↑':(a<b?'↓':'='); } return '↔'; }
function printVal(v){ if(v===undefined) return ''; if(typeof v==='string') return `"${v}"`; return String(v); }

function updateVarsUI(curVars){
  const keys = new Set([...Object.keys(lastVars), ...Object.keys(curVars)]);
  const rows=[];
  for(const k of Array.from(keys).sort()){
    const b=lastVars[k], a=curVars[k]; const changed=(b!==a);
    rows.push(`<tr class="${changed?'changed':''}">
      <td>${k}</td>
      <td class="num">${printVal(b)}</td>
      <td class="num">${printVal(a)}</td>
      <td style="text-align:center">${changed?dirMark(b,a):''}</td>
    </tr>`);
  }
  varsBody.innerHTML = rows.join('');
  lastVars = snapshot(curVars);
  setTimeout(()=>{ for(const tr of varsBody.querySelectorAll('.changed')) tr.classList.remove('changed'); },900);
}

function logTraceLine({ln,text,diff,note}){
  const lnStr = (ln==null)?'(END)':(`行 ${ln}`);
  const code  = text? text.replace(/[&<>"]/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[m])):'';
  const diffStr = (diff && diff.length>0) ? ' <span class="trace-diff">/ 変更: '+diff.map(d=>`${d.name}:${printVal(d.old)}→${printVal(d.now)}`).join(', ')+'</span>' : '';
  const noteStr = note? ` <span class="trace-note">${note}</span>` : '';
  const div=document.createElement('div'); div.className='traceRow';
  div.innerHTML=`<b>${lnStr}</b>  ${code}${noteStr}${diffStr}`;
  traceLog.appendChild(div); traceLog.scrollTop=traceLog.scrollHeight;
}

/* ---------- INPUT モーダル ---------- */
function ask(promptText, preset="", placeholder=""){
  modalPrompt.textContent = promptText || "?";
  modalInput.value = preset;
  modalInput.placeholder = placeholder || "値を入力";
  modal.style.display = "flex";
  modalInput.focus();
  return new Promise((resolve, reject)=>{
    const cleanup=()=>{ modal.style.display="none"; modalOk.onclick=modalCancel.onclick=modalInput.onkeydown=null; };
    modalOk.onclick = ()=>{ const v=modalInput.value; cleanup(); resolve(v); };
    modalCancel.onclick = ()=>{ cleanup(); reject(new Error("cancel")); };
    modalInput.onkeydown = (e)=>{ if(e.key==='Enter') modalOk.click(); if(e.key==='Escape') modalCancel.click(); };
  });
}

/* ---------- 実行 ---------- */
async function execLine(idx){
  const {ln,text}=program[idx];
  const up=text.toUpperCase();

  if(/^REM/.test(up)) return;
  if(/^(END|STOP)$/.test(up)){ running=false; return; }

  // PRINT
  if(/^PRINT\b/i.test(up)){
    const body = text.replace(/^PRINT\s*/i,'');
    const parts=[]; let buf='', inStr=false, depth=0;
    for(let i=0;i<body.length;i++){
      const c=body[i];
      if(c=='"'){ inStr=!inStr; buf+=c; continue; }
      if(!inStr){
        if(c=='('){ depth++; buf+=c; continue; }
        if(c==')'){ depth--; buf+=c; continue; }
        if((c==','||c==';')&&depth==0){ parts.push({expr:buf.trim(),sep:c}); buf=''; continue; }
      }
      buf+=c;
    }
    parts.push({expr:buf.trim(),sep:null});

    let lineOut='', col=0, lastSep=null;
    for(const p of parts){
      if(p.expr.length>0){
        const v=evalExpr(p.expr);
        const s=(typeof v==='string')?v:String(v);
        lineOut+=s; col+=s.length;
      }
      lastSep=p.sep;
      if(p.sep===','){
        const zone=14, rem=col%zone, pad=(rem===0)?zone:(zone-rem);
        lineOut+=' '.repeat(pad); col+=pad;
      }
    }
    W(lineOut + (lastSep===';'?'':'\n'));
    return;
  }

  // INPUT（PROMPT 対応／複数変数）
  if(/^INPUT\b/i.test(up)){
    let promptTxt="?"; let varPart=null, m;
    m=text.match(/^INPUT\s+PROMPT\s+"([^"]*)"\s*:\s*(.+)$/i);
    if(m){ promptTxt=m[1]; varPart=m[2]; }
    else{ m=text.match(/^INPUT\s+(.+)$/i); if(m) varPart=m[1]; }
    if(!varPart) throw new Error("INPUT 構文エラー");

    const names = varPart.split(/\s*,\s*/);
    const placeholder=(names.length===1)? "例: 1" : ("例: "+names.map((_,i)=>i+1).join(", "));

    while(true){
      const ans = await ask(promptTxt,"",placeholder);
      const values = ans.split(/\s*,\s*/);
      if(values.length<names.length){ err("入力が不足しています。もう一度入力してください。"); continue; }

      let ok=true; const parsed=[];
      for(let i=0;i<names.length;i++){
        const raw=(values[i]??"").trim(); if(raw===""){ ok=false; break; }
        const num=Number(raw); if(Number.isNaN(num)){ ok=false; break; }
        parsed.push(num);
      }
      if(!ok){ err("数値で入力してください。例の形式に従って再入力を。"); continue; }
      for(let i=0;i<names.length;i++) setVar(names[i].toUpperCase(), parsed[i]);
      break;
    }
    return;
  }

  // LET 代入（LET 省略可）
  if(/^LET\b/i.test(up) || /^[A-Z]/.test(text)){
    const m=text.replace(/^LET\s+/i,'').match(/^([A-Z][A-Z0-9_]*)\s*=\s*(.+)$/i);
    if(m){ setVar(m[1], evalExpr(m[2])); return; }
  }

  // IF ... THEN ブロック
  let mBlk=text.match(/^IF\s+(.+?)\s+THEN\s*$/i);
  if(mBlk){
    const cond=!!evalExpr(mBlk[1]);
    let depth=0, elseIdx=-1, endIdx=-1;
    for(let j=idx+1;j<program.length;j++){
      const uj=program[j].text.toUpperCase().trim();
      if(/^IF\s+.+\s+THEN\s*$/.test(uj)){ depth++; continue; }
      if(/^END\s+IF$/.test(uj)){ if(depth===0){ endIdx=j; break; } else { depth--; continue; } }
      if(/^ELSE$/.test(uj)){ if(depth===0 && elseIdx===-1) elseIdx=j; }
    }
    if(endIdx<0) throw new Error('IF に対応する END IF が見つかりません');
    if(!cond) pc=(elseIdx>=0?elseIdx:endIdx)-1;
    return;
  }
  // ELSE → 対応する END IF までスキップ
  if(/^ELSE$/i.test(up.trim())){
    let depth=0,endIdx=-1;
    for(let j=idx+1;j<program.length;j++){
      const uj=program[j].text.toUpperCase().trim();
      if(/^IF\s+.+\s+THEN\s*$/.test(uj)){ depth++; continue; }
      if(/^END\s+IF$/.test(uj)){ if(depth===0){ endIdx=j; break; } else { depth--; continue; } }
    }
    if(endIdx<0) throw new Error('ELSE に対応する END IF が見つかりません');
    pc=endIdx-1; return;
  }
  if(/^END\s+IF$/i.test(up.trim())) return;

  // FOR
  let mf=text.match(/^FOR\s+([A-Z][A-Z0-9_]*)\s*=\s*(.+?)\s+TO\s+(.+?)(?:\s+STEP\s+(.+))?$/i);
  if(mf){
    const v=mf[1], init=Number(evalExpr(mf[2])), fin=Number(evalExpr(mf[3]));
    const step=(mf[4]!=null)? Number(evalExpr(mf[4])) : 1;
    if(!isFinite(init)||!isFinite(fin)||!isFinite(step)) throw new Error('FORの値が数値ではありません');
    if(step===0) throw new Error('STEP は 0 にできません');
    setVar(v, init);
    let depth=0, nextIndex=-1;
    for(let j=idx+1;j<program.length;j++){
      const u=program[j].text.toUpperCase();
      if(/^FOR\b/.test(u)) depth++;
      if(/^NEXT\b/.test(u)){ if(depth===0){ nextIndex=j; break; } else depth--; }
    }
    if(nextIndex<0) throw new Error('FOR に対応する NEXT が見つかりません');
    const exec=(step>0)?(init<=fin):(init>=fin);
    if(!exec){ pc=nextIndex; return; }
    loopStack.push({var:v, fin, step, start:idx+1, nextIndex});
    return;
  }

  // NEXT
  let mn=text.match(/^NEXT\s*([A-Z][A-Z0-9_]*)?\s*$/i);
  if(mn){
    if(loopStack.length===0) throw new Error('NEXT に対応する FOR がありません');
    const ctx=loopStack[loopStack.length-1];
    if(mn[1] && mn[1].toUpperCase()!==ctx.var) throw new Error('NEXT '+mn[1]+' は FOR '+ctx.var+' と一致しません');
    const nv=Number(getVar(ctx.var)) + ctx.step; setVar(ctx.var, nv);
    const cont=(ctx.step>0)?(nv<=ctx.fin):(nv>=ctx.fin);
    if(cont) pc=ctx.start-1; else loopStack.pop();
    return;
  }

  // GOTO
  let mg=text.match(/^GOTO\s+(\d+)\s*$/i);
  if(mg){ const t=+mg[1]; if(lineIndex[t]==null) throw new Error('行 '+t+' が見つかりません'); pc=lineIndex[t]-1; return; }

  // IF ... THEN 単文
  let mIf=text.match(/^IF\s+(.+?)\s+THEN\s+(.+)$/i);
  if(mIf){
    const cond=!!evalExpr(mIf[1]);
    if(cond){
      const stmt=mIf[2].trim();
      if(/^\d+$/.test(stmt)){
        const t=+stmt; if(lineIndex[t]==null) throw new Error('行 '+t+' が見つかりません'); pc=lineIndex[t]-1;
      }else{
        const tmp={ln, text:stmt}; program.splice(idx+1,0,tmp);
        for(const k in lineIndex){ if(lineIndex[k]>idx) lineIndex[k]++; }
      }
    }
    return;
  }

  throw new Error('未知の文: '+text);
}

/* ---------- 実行ループ & ステップ ---------- */
function diffVars(before,after){
  const keys=new Set([...Object.keys(before), ...Object.keys(after)]);
  const out=[]; for(const k of keys){ const b=before[k], a=after[k]; if(b!==a) out.push({name:k, old:b, now:a}); }
  return out.sort((x,y)=>x.name.localeCompare(y.name));
}
function focusLine(ln){
  if(!ln) return;
  const lines=ed.value.split(/\r?\n/); let pos=0;
  for(const line of lines){
    const m=line.match(/^(\d+)\s+/);
    if(m && Number(m[1])===ln){
      ed.focus();
      if(ed.setSelectionRange) ed.setSelectionRange(pos, pos+line.length);
      const upto=ed.value.slice(0,pos); const n=upto.split(/\r?\n/).length; const lineHeight=18;
      ed.scrollTop = Math.max(0,(n-5)*lineHeight); return;
    }
    pos += line.length+1;
  }
}

async function stepOnce(){
  if(!program || program.length===0) return;
  if(pc>=program.length){ logTraceLine({ln:null,text:'<END>',note:'プログラム終了'}); running=false; return; }

  const before=snapshot(vars); const prevPc=pc;
  try{ await execLine(pc); }catch(e){ err(`実行時エラー（行 ${program[pc].ln}）: ${e.message}`); running=false; }
  pc++;

  const after=snapshot(vars); const diff=diffVars(before,after);
  const curLn=program[prevPc].ln; const curTx=program[prevPc].text;
  focusLine(curLn); updateVarsUI(after); logTraceLine({ln:curLn,text:curTx,diff}); waiting=true;
}

async function runToNextPause(){
  while(stepMode && waiting===false && pc<program.length){
    const before=snapshot(vars); const prevPc=pc;
    try{ await execLine(pc);}catch(e){ err(`実行時エラー（行 ${program[pc].ln}）: ${e.message}`); running=false; }
    pc++;
    const after=snapshot(vars); const diff=diffVars(before,after);
    const curLn=program[prevPc].ln; const curTx=program[prevPc].text;
    focusLine(curLn); updateVarsUI(after); logTraceLine({ln:curLn,text:curTx,diff});
    waiting=true; break;
  }
}

async function run(){
  C(); traceLog.innerHTML=''; resetState(); running=true;
  try{ parseProgram(ed.value); }catch(e){ err('構文エラー: '+e.message); return; }
  W('🚀 プログラム実行開始\n');
  lastVars=snapshot(vars); updateVarsUI(vars);
  if(chkStep.checked){ stepMode=true; waiting=false; await stepOnce(); return; }
  // 通常実行
  while(running && pc<program.length){
    const before=snapshot(vars); const prevPc=pc;
    try{ await execLine(pc);}catch(e){ err(`実行時エラー（行 ${program[pc].ln}）: ${e.message}`); running=false; }
    pc++;
    const after=snapshot(vars); const diff=diffVars(before,after);
    const curLn=program[prevPc].ln; const curTx=program[prevPc].text;
    updateVarsUI(after); logTraceLine({ln:curLn,text:curTx,diff});
    if(pc>200000){ err('実行が長すぎます（無限ループ？）'); running=false; }
  }
}

function stop(){ running=false; }
function resetAll(){
  stop(); ed.value=SAMPLE_CODE; localStorage.setItem('jis_basic_last_code', ed.value);
  C(); traceLog.innerHTML=''; updateVarsUI({}); W('🔄 リセットしました\n');
}
function clearAll(){
  stop(); ed.value=''; localStorage.setItem('jis_basic_last_code', ed.value);
  C(); traceLog.innerHTML=''; updateVarsUI({}); W('🧹 クリアしました（新しいプログラムを入力してください）\n');
}

/* ---------- イベント ---------- */
document.getElementById('btnRun').onclick = ()=>{ if(!running) run(); };
document.getElementById('btnStop').onclick= ()=> stop();
document.getElementById('btnReset').onclick=()=> resetAll();
document.getElementById('btnClear').onclick=()=> clearAll();

chkStep.addEventListener('change', ()=> stepMode=chkStep.checked);
btnStep.addEventListener('click', async()=>{ stepMode=true; chkStep.checked=true;
  if(!running){ C(); traceLog.innerHTML=''; resetState(); running=true; try{ parseProgram(ed.value); }catch(e){ err('構文エラー: '+e.message); running=false; return; } }
  waiting=false; await stepOnce();
});
btnCont.addEventListener('click', async()=>{ stepMode=true; chkStep.checked=true; waiting=false; await runToNextPause(); });

</script>
</body>
</html>
