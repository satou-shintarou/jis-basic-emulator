<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JIS-BASICエミュレータ（FOR/NEXT・CSP対応・INPUT/IFブロック対応）</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", "Meiryo", sans-serif; background:#0b0b0c; color:#e7ecef; }
  header { position: sticky; top:0; z-index:10; display:flex; gap:.5rem; align-items:center; padding:.75rem 1rem; border-bottom:1px solid #262a33; background:rgba(11,11,12,.9); backdrop-filter:saturate(150%) blur(6px); }
  h1 { font-size:1.05rem; margin:0 .5rem 0 0; font-weight:800; }
  button { border:0; border-radius:14px; padding:.6rem .9rem; font-weight:700; cursor:pointer; }
  .run { background:#10b981; color:#05130f; }
  .stop { background:#ef4444; color:#2b0707; }
  .reset { background:#0ea5e9; color:#07121a; }
  .clear { background:#6b7280; color:#0a0c0f; }
  .wrap { max-width:1200px; margin: 0 auto; padding: 1rem; display:grid; grid-template-columns: 1fr 1fr; gap:1rem; }
  .card { background:#121317; border:1px solid #1f2330; border-radius:18px; }
  .card h2 { margin:0; padding:.75rem 1rem; font-size:.9rem; opacity:.85; border-bottom:1px solid #1f2330;}
  textarea { width:100%; min-height:520px; background:#0c0d11; color:#e8eefa; border:1px solid #2a2f3b; border-radius:12px; padding:.9rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:13px; line-height:1.6; }
  .console { min-height:520px; background:#000; color:#38f08f; border:1px solid #2a2f3b; border-radius:12px; padding:.9rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:13px; overflow:auto; white-space:pre-wrap; }
  .hint { padding:.5rem 1rem 1rem 1rem; font-size:.8rem; color:#b8c4d6; opacity:.8; }
  @media (max-width: 900px) {
    .wrap { grid-template-columns: 1fr; }
    textarea, .console { min-height: 360px; }
  }
  .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.65); z-index:50; }
  .modal .panel { width:min(92vw, 520px); background:#161821; border:1px solid #2a2f3b; border-radius:16px; padding:1rem; }
  .modal input { width:100%; background:#0c0d11; color:#e8eefa; border:1px solid #2a2f3b; border-radius:10px; padding:.6rem .7rem; font-family: ui-monospace, monospace; }
  .right { display:flex; gap:.5rem; justify-content:flex-end; }
</style>
</head>
<body>
  <header>
    <h1>JIS-BASICエミュレータ（FOR/NEXT・CSP対応・INPUT/IFブロック対応）</h1>
    <button class="run"   id="btnRun">▶ 実行</button>
    <button class="stop"  id="btnStop">■ 停止</button>
    <button class="reset" id="btnReset">↺ リセット</button>
    <button class="clear" id="btnClear">🧹 クリア</button>
  </header>

  <div class="wrap">
    <div class="card">
      <h2>📘 コードエディタ</h2>
      <div style="padding:1rem">
        <textarea id="editor" spellcheck="false">100 PRINT "テスト開始"
110 LET S = 0
120 FOR I = 1 TO 5
130 LET S = S + I
140 NEXT I
150 IF S >= 15 THEN 180
160 PRINT "ここは表示されないはず"
170 GOTO 190
180 PRINT "合計="; S
190 END</textarea>
        <div class="hint">
          対応：<code>PRINT</code>（<code>,</code>は14桁タブ、<code>;</code>は改行なし／式評価可）、
          <code>INPUT [PROMPT "…"] : 変数[,変数…]</code>、
          <code>LET/代入</code>、
          <code>IF … THEN …</code>（単文）、
          <code>IF … THEN</code>／<code>ELSE</code>／<code>END IF</code>（ブロック）、
          <code>FOR … TO … [STEP …]</code>、<code>NEXT</code>、
          <code>GOTO</code>、<code>END/STOP</code>。
        </div>
      </div>
    </div>

    <div class="card">
      <h2>🖥️ 実行画面</h2>
      <div style="padding:1rem"><div class="console" id="console"></div></div>
    </div>
  </div>

  <!-- INPUT Modal -->
  <div class="modal" id="modal">
    <div class="panel">
      <div id="modalPrompt" style="margin:.25rem 0 .5rem 0">? </div>
      <input id="modalInput" placeholder="" />
      <div class="right" style="margin-top:.6rem">
        <button class="clear"  id="modalCancel">キャンセル</button>
        <button class="run"    id="modalOk">OK</button>
      </div>
    </div>
  </div>

<script>
(function(){
  const con = document.getElementById('console');
  const ed  = document.getElementById('editor');
  const initialCode = ed.value;
  let running=false, pc=0, vars={}, lineIndex={}, program=[];
  let loopStack=[];

  function W(s){ con.textContent += s; con.scrollTop=con.scrollHeight; }
  function C(){ con.textContent=''; }
  function err(s){ W('⚠️ '+s+'\n'); }

// === 文字正規化（全角やスマート記号→ASCII） =========================
function normalizeCode(src) {
  // 1) 全角ASCII（！～）を半角に
  src = src.replace(/[\uFF01-\uFF5E]/g, ch =>
    String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)
  );
  // 2) よく混入する類似記号を置換
  const map = {
    '　':' ',  // 全角スペース
    '“':'"', '”':'"', '„':'"', '‟':'"',  // スマート引用符
    '‘':"'", '’':"'", '‚':"'",          // スマートアポストロフィ
    '‹':'<', '›':'>',                   // 似た山括弧
    '≤':'<=', '≥':'>=',                 // 以上/以下
    '×':'*', '÷':'/', '−':'-',          // かける/わる/全角マイナス
    '，':',', '；':';', '：':':',        // 全角句読点
    '\u3000':' '                         // IDEOGRAPHIC SPACE
  };
  src = src.replace(/[“”„‟‘’‚‹›≤≥×÷−，；：\u3000]/g, ch => map[ch] || ch);
  // 3) ゼロ幅系の削除（コピペで混ざることがある）
  src = src.replace(/[\u200B-\u200D\uFEFF]/g, '');
  return src;
}


  // === INPUT モーダル ===
  const modal        = document.getElementById('modal');
  const modalPrompt  = document.getElementById('modalPrompt');
  const modalInput   = document.getElementById('modalInput');
  const modalOk      = document.getElementById('modalOk');
  const modalCancel  = document.getElementById('modalCancel');

  function ask(promptText, preset="", placeholder="") {
    modalPrompt.textContent = promptText || "?";
    modalInput.value = preset;
    modalInput.placeholder = placeholder || "値を入力";
    modal.style.display = "flex";
    modalInput.focus();
    return new Promise((resolve, reject) => {
      const cleanup = () => {
        modal.style.display = "none";
        modalOk.onclick = modalCancel.onclick = modalInput.onkeydown = null;
      };
      modalOk.onclick = () => { const v = modalInput.value; cleanup(); resolve(v); };
      modalCancel.onclick = () => { cleanup(); reject(new Error("cancel")); };
      modalInput.onkeydown = (e) => {
        if (e.key === "Enter") modalOk.click();
        if (e.key === "Escape") modalCancel.click();
      };
    });
  }

  // ----- 文字列正規化（BOMや不可視空白など） -----
  function normalizeLine(s) {
    if (!s) return "";
    s = s.replace(/^\uFEFF/, ""); // 行頭BOM
    s = s.replace(/^[\uFEFF\u200B\u200C\u200D\u00A0\u3000]+/, ""); // 不可視/全角空白
    s = s.replace(/^\t+/, m => " ".repeat(m.length)); // タブ→空白
    return s;
  }

  // ----- Tokenizer & Expression parser（eval禁止） -----
  function tokenize(s){
    const out=[]; let i=0;
    const isAlpha=c=>/[A-Za-z_]/.test(c), isAlnum=c=>/[A-Za-z0-9_]/.test(c);
    while(i<s.length){
      const ch=s[i];
      if(/\s/.test(ch)){ i++; continue; }
      if(ch=='"'){ let j=i+1, buf=''; while(j<s.length && s[j]!=='"'){ buf+=s[j++]; } j++; out.push({t:'str', v:buf}); i=j; continue; }
      if(/[0-9.]/.test(ch)){ let j=i, num='', dot=false; while(j<s.length && /[0-9.]/.test(s[j])){ if(s[j]==='.'&&dot) break; if(s[j]==='.') dot=true; num+=s[j++]; } out.push({t:'num', v:Number(num)}); i=j; continue; }
      if(isAlpha(ch)){ let j=i, id=''; while(j<s.length && isAlnum(s[j])) id+=s[j++]; const up=id.toUpperCase(); if(up==='AND'||up==='OR'){ out.push({t:'op', v:up}); } else { out.push({t:'id', v:up}); } i=j; continue; }
      const two=s.slice(i,i+2);
      if(['>=','<=','<>'].includes(two)){ out.push({t:'op', v:two}); i+=2; continue; }
      if('+-*/^=()<>'.includes(ch)){   // ← "<>" を追加
  if(ch==='('||ch===')') out.push({t:'par', v:ch});
  else out.push({t:'op', v:ch});
  i++; continue;
}

      if(ch===','){ out.push({t:'comma'}); i++; continue; }
      throw new Error('未知の文字: ' + ch + ' (U+' +
  ch.charCodeAt(0).toString(16).toUpperCase().padStart(4,'0') + ')');

    }
    out.push({t:'eof'}); return out;
  }

  function evalExpr(expr){
    const tokens=tokenize(expr); let i=0;
    const peek=()=>tokens[i]||{t:'eof'};
    const consume=()=>tokens[i++]||{t:'eof'};
    const toNum=v=> typeof v==='boolean'? (v?1:0) : (typeof v==='number'? v : Number(v));

    const parseExpr=()=>parseOr();
    function parseOr(){ let L=parseAnd(); while(peek().t==='op'&&peek().v==='OR'){ consume(); const R=parseAnd(); L=(toNum(L)||toNum(R))?1:0; } return L; }
    function parseAnd(){ let L=parseCmp(); while(peek().t==='op'&&peek().v==='AND'){ consume(); const R=parseCmp(); L=(toNum(L)&&toNum(R))?1:0; } return L; }
    function parseCmp(){ let L=parseAdd(); const p=peek(); if(p.t==='op'&&['=','<>','<','<=','>','>='].includes(p.v)){ consume(); const R=parseAdd(); switch(p.v){case '=':return (L==R)?1:0;case '<>':return (L!=R)?1:0;case '<':return (toNum(L)<toNum(R))?1:0;case '<=':return (toNum(L)<=toNum(R))?1:0;case '>':return (toNum(L)>toNum(R))?1:0;case '>=':return (toNum(L)>=toNum(R))?1:0;} } return L; }
    function parseAdd(){ let L=parseMul(); while(peek().t==='op'&&(peek().v==='+'||peek().v==='-')){ const op=consume().v; const R=parseMul(); L=(op==='+')? toNum(L)+toNum(R) : toNum(L)-toNum(R); } return L; }
    function parseMul(){ let L=parsePow(); while(peek().t==='op'&&(peek().v==='*'||peek().v==='/')){ const op=consume().v; const R=parsePow(); L=(op==='*')? toNum(L)*toNum(R) : toNum(L)/toNum(R); } return L; }
    function parsePow(){ let L=parseUnary(); while(peek().t==='op'&&peek().v==='^'){ consume(); const R=parseUnary(); L=Math.pow(toNum(L), toNum(R)); } return L; }
    function parseUnary(){ const p=peek(); if(p.t==='op'&&(p.v==='+'||p.v==='-')){ consume(); const v=parseUnary(); return p.v==='-'? -toNum(v) : toNum(v); } return parsePrimary(); }
    function parsePrimary(){
      const t=peek();
      if(t.t==='num'){ consume(); return t.v; }
      if(t.t==='str'){ consume(); return t.v; }
      if(t.t==='id'){ const name=t.v; consume(); return getVar(name); }
      if(t.t==='par'&&t.v==='('){ consume(); const v=parseExpr(); if(peek().t!=='par'||peek().v!==')') throw new Error(')が必要'); consume(); return v; }
      throw new Error('式エラー');
    }
    return parseExpr();
  }

  // ----- Variables -----
  function toKey(s){ return s.toUpperCase(); }
  function getVar(n){ return (n=toKey(n), vars[n]??0); }
  function setVar(n,v){ vars[toKey(n)]=v; }

  // ----- Program parse -----
  function parseProgram(src){
    src = src.replace(/^\uFEFF/, ""); // 全体先頭BOM
    const raw=src.split(/\r?\n/); program=[]; lineIndex={};
    for(const r of raw){
      const line = normalizeLine(r);
      if(!line.trim()) continue;
      const m=line.match(/^(\d+)\s+(.*)$/);
      if(!m) throw new Error('行番号が必要: '+line);
      program.push({ln:parseInt(m[1],10), text:m[2].trim()});
    }
    program.sort((a,b)=>a.ln-b.ln);
    program.forEach((st,i)=> lineIndex[st.ln]=i);
  }

  // ----- EXEC -----
  async function execLine(idx){
    const {ln,text}=program[idx];
    const up=text.toUpperCase();

    if(/^REM/.test(up)) return;
    if(/^(END|STOP)$/.test(up)) {running=false; return;}

    // PRINT（式評価 / , は14列タブ / ; は改行抑制）
    if(/^PRINT\b/i.test(up)){
      const body = text.replace(/^PRINT\s*/i,'');
      // トップレベルで , / ; で分割（"..." と () は保護）
      const parts = [];
      let buf = '', inStr = false, depth = 0;
      for (let i = 0; i < body.length; i++) {
        const c = body[i];
        if (c === '"') { inStr = !inStr; buf += c; continue; }
        if (!inStr) {
          if (c === '(') { depth++; buf += c; continue; }
          if (c === ')') { depth--; buf += c; continue; }
          if ((c === ',' || c === ';') && depth === 0) {
            parts.push({ expr: buf.trim(), sep: c });
            buf = '';
            continue;
          }
        }
        buf += c;
      }
      parts.push({ expr: buf.trim(), sep: null });

      let lineOut = '', col = 0, lastSep = null;
      for (const p of parts) {
        if (p.expr.length > 0) {
          const v = evalExpr(p.expr);
          const s = (typeof v === 'string') ? v : String(v);
          lineOut += s;
          col += s.length;
        }
        lastSep = p.sep;
        if (p.sep === ',') {
          const zone = 14;
          const rem = col % zone;
          const pad = (rem === 0) ? zone : (zone - rem);
          lineOut += ' '.repeat(pad);
          col += pad;
        } // ';' は改行抑制なので何もしない
      }
      W(lineOut + (lastSep === ';' ? '' : '\n'));
      return;
    }

    // === IF … THEN（ブロック）===
    let mIfBlk = text.match(/^IF\s+(.+?)\s+THEN\s*$/i);
    if (mIfBlk) {
      const cond = !!evalExpr(mIfBlk[1]);
      // 対応する ELSE / END IF を探索（入れ子対応）
      let depth = 0, elseIdx = -1, endIdx = -1;
      for (let j = idx + 1; j < program.length; j++) {
        const uj = program[j].text.toUpperCase().trim();
        if (/^IF\s+.+\s+THEN\s*$/.test(uj)) { depth++; continue; }
        if (/^END\s+IF$/.test(uj)) {
          if (depth === 0) { endIdx = j; break; } else { depth--; continue; }
        }
        if (/^ELSE$/.test(uj)) {
          if (depth === 0 && elseIdx === -1) elseIdx = j;
        }
      }
      if (endIdx < 0) throw new Error('IF に対応する END IF が見つかりません');
      if (!cond) pc = (elseIdx >= 0 ? elseIdx : endIdx) - 1;
      return;
    }
    // === ELSE：対応する END IF までスキップ ===
    if (/^ELSE$/i.test(up.trim())) {
      let depth = 0, endIdx = -1;
      for (let j = idx + 1; j < program.length; j++) {
        const uj = program[j].text.toUpperCase().trim();
        if (/^IF\s+.+\s+THEN\s*$/.test(uj)) { depth++; continue; }
        if (/^END\s+IF$/.test(uj)) {
          if (depth === 0) { endIdx = j; break; } else { depth--; continue; }
        }
      }
      if (endIdx < 0) throw new Error('ELSE に対応する END IF が見つかりません');
      pc = endIdx - 1;
      return;
    }
    // === END IF：no-op ===
    if (/^END\s+IF$/i.test(up.trim())) { return; }

// === INPUT（PROMPT 対応／複数変数対応：バリデーション付き）===
if (/^INPUT\b/i.test(up)) {
  let promptTxt = "?";
  let varPart = null;
  let m;

  // 1) 解析
  m = text.match(/^INPUT\s+PROMPT\s+"([^"]*)"\s*:\s*(.+)$/i);
  if (m) { promptTxt = m[1]; varPart = m[2]; }
  else {
    m = text.match(/^INPUT\s+(.+)$/i);
    if (m) { varPart = m[1]; }
  }
  if (!varPart) throw new Error("INPUT 構文エラー");

  const names = varPart.split(/\s*,\s*/);
  const placeholder = (names.length === 1)
    ? "例: 1"
    : "例: " + names.map((_, i) => i + 1).join(", ");

  // 2) 入力 → 検証 → 代入（NGならリトライ）
  while (true) {
    const ans = await ask(promptTxt, "", placeholder);
    const values = ans.split(/\s*,\s*/);

    // 個数チェック
    if (values.length < names.length) {
      err("入力が不足しています。もう一度入力してください。");
      continue;
    }

    // 空欄/非数チェック（全部数値として解釈を試みる）
    let ok = true;
    const parsed = [];
    for (let i = 0; i < names.length; i++) {
      const raw = (values[i] ?? "").trim();
      if (raw === "") { ok = false; break; }
      const num = Number(raw);
      if (Number.isNaN(num)) { ok = false; break; }
      parsed.push(num);
    }
    if (!ok) {
      err("数値で入力してください。例の形式に従って再入力を。");
      continue;
    }

    // ここまで来たら代入
    for (let i = 0; i < names.length; i++) {
      setVar(names[i].toUpperCase(), parsed[i]);
    }
    break;
  }
  return;
}
   


    // LET / 代入（LET 省略可）
    if(/^LET\b/i.test(up) || /^[A-Z]/.test(text)){
      const m=text.replace(/^LET\s+/i,'').match(/^([A-Z][A-Z0-9_]*)\s*=\s*(.+)$/i);
      if(m){ setVar(m[1], evalExpr(m[2])); return; }
    }

    // FOR
    let mf = text.match(/^FOR\s+([A-Z][A-Z0-9_]*)\s*=\s*(.+?)\s+TO\s+(.+?)(?:\s+STEP\s+(.+))?\s*$/i);
    if(mf){
      const v=mf[1], init=Number(evalExpr(mf[2])), fin=Number(evalExpr(mf[3]));
      const step = (mf[4]!=null)? Number(evalExpr(mf[4])) : 1;
      if(!isFinite(init)||!isFinite(fin)||!isFinite(step)) throw new Error('FORの値が数値ではありません');
      if(step===0) throw new Error('STEP は 0 にできません');
      setVar(v, init);
      // 対応する NEXT を探索（入れ子対応）
      let depth=0, nextIndex=-1;
      for(let j=idx+1;j<program.length;j++){
        const u=program[j].text.toUpperCase();
        if(/^FOR\b/.test(u)) depth++;
        if(/^NEXT\b/.test(u)){
          if(depth===0){ nextIndex=j; break; }
          else depth--;
        }
      }
      if(nextIndex<0) throw new Error('FOR に対応する NEXT が見つかりません');
      const exec = (step>0)? (init<=fin) : (init>=fin);
      if(!exec){ pc=nextIndex; return; }
      loopStack.push({var:v, fin, step, start:idx+1, forIndex:idx, nextIndex});
      return;
    }

    // NEXT
    let mn=text.match(/^NEXT\s*([A-Z][A-Z0-9_]*)?\s*$/i);
    if(mn){
      if(loopStack.length===0) throw new Error('NEXT に対応する FOR がありません');
      const ctx=loopStack[loopStack.length-1];
      if(mn[1] && mn[1].toUpperCase()!==ctx.var) throw new Error('NEXT '+mn[1]+' は FOR '+ctx.var+' と一致しません');
      const nv = Number(getVar(ctx.var)) + ctx.step;
      setVar(ctx.var, nv);
      const cont = (ctx.step>0)? (nv<=ctx.fin) : (nv>=ctx.fin);
      if(cont) pc=ctx.start-1; else loopStack.pop();
      return;
    }

    // GOTO
    let mg=text.match(/^GOTO\s+(\d+)\s*$/i);
    if(mg){ const t=+mg[1]; if(lineIndex[t]==null) throw new Error('行 '+t+' が見つかりません'); pc=lineIndex[t]-1; return; }

    // IF ... THEN 単文（GOTO行番号 または 代入/PRINT一文）
    let mIf=text.match(/^IF\s+(.+?)\s+THEN\s+(.+)$/i);
    if(mIf){
      const cond = !!evalExpr(mIf[1]);
      if(cond){
        const stmt = mIf[2].trim();
        if(/^\d+$/.test(stmt)){
          const t=+stmt; if(lineIndex[t]==null) throw new Error('行 '+t+' が見つかりません'); pc=lineIndex[t]-1;
        }else{
          // 単文をその場で1行として挿入して実行
          const tmp = { ln, text: stmt }; program.splice(idx+1,0,tmp);
          for(const k in lineIndex){ if(lineIndex[k]>idx) lineIndex[k]++; }
        }
      }
      return;
    }

    throw new Error('未知の文: '+text);
  }

  async function run(){
    C(); vars={}; loopStack=[]; pc=0; running=true; W('🚀 プログラム実行開始\n');
    try{ parseProgram(normalizeCode(ed.value)); }catch(e){ err('構文エラー: '+e.message); return; }
    while(running&&pc<program.length){
      try{ await execLine(pc);}catch(e){ err('実行時エラー（行 '+program[pc].ln+'）: '+e.message); running=false; }
      pc++;
      if(pc>100000){ err('実行が長すぎます（無限ループ？）'); running=false; }
    }
  }

  function stop(){ running=false; }
  function reset(){ stop(); ed.value=initialCode; C(); W('🔄 リセットしました\n'); }
  function clear(){ stop(); ed.value=''; C(); W('🧹 クリアしました（新しいプログラムを入力してください）\n'); }

  document.getElementById('btnRun').onclick=()=>{ if(!running) run(); };
  document.getElementById('btnStop').onclick=()=>stop();
  document.getElementById('btnReset').onclick=()=>reset();
  document.getElementById('btnClear').onclick=()=>clear();
})();
</script>
</body>
</html>
